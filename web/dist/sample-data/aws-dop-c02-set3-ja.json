{
  "exam": {
    "id": "aws-dop-c02-set3-ja",
    "name": "AWS DOP-C02 模擬試験 #3",
    "code": "DOP-C02",
    "provider": "AWS",
    "language": "ja",
    "description": "AWS DevOpsエンジニアプロフェッショナル認定試験模擬問題 - 第3セット",
    "totalQuestions": 40,
    "passingScore": 75,
    "examTime": 180,
    "domains": [
      {"id": 1, "name": "SDLCの自動化", "weight": 22},
      {"id": 2, "name": "構成管理とIaC", "weight": 17},
      {"id": 3, "name": "回復力のあるクラウドソリューション", "weight": 15},
      {"id": 4, "name": "モニタリングとロギング", "weight": 15},
      {"id": 5, "name": "インシデントとイベント対応", "weight": 14},
      {"id": 6, "name": "セキュリティとコンプライアンス", "weight": 17}
    ],
    "tags": ["AWS", "DevOps", "DOP", "認定試験", "プロフェッショナル"]
  },
  "questions": [
    {"id": "q1", "domain": 1, "question": "チームが複数のGitブランチを使用して開発しています。テストに合格したコードのみがメインブランチにマージできるようにするにはどうすればよいですか？", "options": {"A": "手動コードレビュー", "B": "CodeCommit承認ルールを設定してCodeBuildビルド成功を要求", "C": "Lambdaで検証", "D": "CloudWatchで監視"}, "answer": "B", "explanation": "CodeCommit承認ルールは、プルリクエストが特定の条件（関連するビルドの成功など）を満たす必要があることを要求でき、マージが許可されます。"},
    {"id": "q2", "domain": 1, "question": "サードパーティのアーティファクト（npmパッケージなど）をキャッシュしてビルドを高速化し、外部依存関係のリスクを回避する必要があります。どのように実現しますか？", "options": {"A": "毎回ビルド時にダウンロード", "B": "AWS CodeArtifactをプライベートリポジトリとして使用", "C": "S3に保存", "D": "EFSを使用"}, "answer": "B", "explanation": "CodeArtifactはマネージドアーティファクトリポジトリサービスで、上流パッケージ（npm、Maven、PyPIなど）をキャッシュでき、外部依存関係のリスクを軽減しビルドを高速化します。"},
    {"id": "q3", "domain": 1, "question": "ECSサービスがCodeDeployブルーグリーンデプロイを使用しています。検証失敗時に自動ロールバックするにはどのように設定しますか？", "options": {"A": "手動ロールバック", "B": "CloudWatchアラームをトリガーとして自動ロールバックを設定", "C": "Lambdaで監視", "D": "ヘルスチェック間隔を延長"}, "answer": "B", "explanation": "CodeDeployはCloudWatchアラームをロールバックトリガーとして設定することをサポートし、アラームがALARM状態になると自動的に前のバージョンにロールバックします。"},
    {"id": "q4", "domain": 2, "question": "CloudFormationテンプレートで再利用可能なリソースの組み合わせを定義する必要があります。どのように実現しますか？", "options": {"A": "コピー＆ペースト", "B": "AWS::CloudFormation::Stackネストスタックを使用", "C": "長いテンプレートを使用", "D": "複数の独立したスタックを使用"}, "answer": "B", "explanation": "ネストスタックは再利用可能なリソースの組み合わせを個別のテンプレートにカプセル化し、メインテンプレートで参照してモジュール化と再利用を実現します。"},
    {"id": "q5", "domain": 2, "question": "Systems Manager AutomationドキュメントはLambdaと比較してどのような利点がありますか？", "options": {"A": "実行速度が速い", "B": "AWS API呼び出しとマルチステップオーケストレーションをネイティブでサポートし、コード記述不要", "C": "コストが低い", "D": "より多くの言語をサポート"}, "answer": "B", "explanation": "SSM Automationドキュメントは組み込みのAWS APIステップとフロー制御を持ち、Lambdaコードを書いて維持することなく、マルチステップ自動化タスクを簡単にオーケストレーションできます。"},
    {"id": "q6", "domain": 2, "question": "EC2インスタンスの構成変更時に自動的に構成を再適用する必要があります。Systems Managerでどのように実現しますか？", "options": {"A": "コマンドを手動実行", "B": "State Managerアソシエーションを使用してスケジュールで構成を適用", "C": "CloudWatch Eventsを使用", "D": "Auto Scalingを使用"}, "answer": "B", "explanation": "State Managerはアソシエーションを作成でき、スケジュールまたは変更時に対象インスタンスに構成ドキュメントを自動適用し、構成の一貫性を確保します。"},
    {"id": "q7", "domain": 3, "question": "グローバルに低レイテンシで動的コンテンツを提供する必要があります。どのように設計しますか？", "options": {"A": "単一リージョンデプロイ", "B": "CloudFrontとLambda@Edgeを組み合わせて動的リクエストを処理", "C": "インスタンスサイズを増加", "D": "Route 53を使用"}, "answer": "B", "explanation": "CloudFrontエッジロケーションとLambda@Edgeを組み合わせることで、ユーザーに近い場所で動的リクエストを処理し、レイテンシを大幅に削減できます。"},
    {"id": "q8", "domain": 3, "question": "データベースメンテナンス中もアプリケーションが読み取りサービスを提供できるようにする必要があります。どのように設計しますか？", "options": {"A": "ダウンタイムを受け入れる", "B": "RDSリードレプリカを使用し、プライマリが利用不可の場合にアプリケーションがリードレプリカに切り替え", "C": "より大きなインスタンスを使用", "D": "キャッシュを使用"}, "answer": "B", "explanation": "リードレプリカはプライマリメンテナンス中も利用可能で、アプリケーションは読み取りリクエストをリードレプリカにルーティングでき、書き込み操作はプライマリ回復を待ってキューに入れます。"},
    {"id": "q9", "domain": 3, "question": "リージョン全体の障害に耐えられるアーキテクチャを設計する必要があります。重要なコンポーネントは？", "options": {"A": "より大きなインスタンス", "B": "マルチリージョンデプロイ、クロスリージョンレプリケーション、Route 53ヘルスチェックとフェイルオーバー", "C": "より多くのAZ", "D": "Reserved Instances"}, "answer": "B", "explanation": "マルチリージョンデプロイはリージョンレベルの冗長性を提供し、データのクロスリージョンレプリケーションはデータ可用性を確保し、Route 53ヘルスチェックは健全なリージョンに自動フェイルオーバーします。"},
    {"id": "q10", "domain": 4, "question": "マイクロサービスアーキテクチャのサービス依存関係グラフを作成する必要があります。どのツールを使用しますか？", "options": {"A": "CloudWatch Logs", "B": "AWS X-Rayサービスマップ", "C": "VPC Flow Logs", "D": "CloudTrail"}, "answer": "B", "explanation": "X-Rayサービスマップはサービス間の依存関係を自動検出して可視化し、リクエストフローとレイテンシデータを表示し、マイクロサービスアーキテクチャの理解に役立ちます。"},
    {"id": "q11", "domain": 4, "question": "カスタムアプリケーションメトリクスを収集し、コード変更を最小限に抑える必要があります。どのように実現しますか？", "options": {"A": "アプリケーションコードを変更", "B": "CloudWatch AgentのStatsDプロトコルを使用", "C": "VPC Flow Logsを使用", "D": "CloudTrailを使用"}, "answer": "B", "explanation": "CloudWatch AgentはStatsDプロトコルをサポートし、アプリケーションはローカルポートにUDPメトリクスを送信するだけで、AgentがCloudWatchに自動転送し、コード変更を最小化します。"},
    {"id": "q12", "domain": 4, "question": "ログ内容に基づいてアラームしきい値を動的に調整する必要があります。どのように実現しますか？", "options": {"A": "手動調整", "B": "CloudWatch Metric Filtersを使用してログからメトリクスを作成し、Anomaly Detectionと組み合わせ", "C": "固定しきい値", "D": "Lambdaで処理"}, "answer": "B", "explanation": "Metric Filtersはログから数値をメトリクスとして抽出し、Anomaly Detectionは履歴データに基づいて期待範囲を動的に計算し、インテリジェントアラームを実現します。"},
    {"id": "q13", "domain": 5, "question": "セキュリティイベント発生時に影響を受けたEC2インスタンスを自動隔離する必要があります。どのように実現しますか？", "options": {"A": "手動隔離", "B": "GuardDuty検出→EventBridge→Lambdaがセキュリティグループを変更してインスタンスを隔離", "C": "NACLを使用", "D": "インスタンスを終了"}, "answer": "B", "explanation": "Lambdaはインスタンスのセキュリティグループを隔離セキュリティグループ（フォレンジックアクセスのみ許可）に変更でき、証拠を保持しながらさらなる被害を防ぎます。"},
    {"id": "q14", "domain": 5, "question": "バースト的なトラフィックを処理できるキューコンシューマーを自動スケーリングする必要があります。どのように設計しますか？", "options": {"A": "固定コンシューマー数", "B": "SQS ApproximateNumberOfMessagesメトリクスに基づくTarget Trackingポリシー", "C": "手動スケーリング", "D": "より大きなインスタンスを使用"}, "answer": "B", "explanation": "ASG Target Trackingポリシーはカスタムメトリクス（インスタンスあたりのメッセージ数など）に基づいてコンシューマー数を自動調整し、バースト的なトラフィックに迅速に対応できます。"},
    {"id": "q15", "domain": 5, "question": "RDS自動バックアップが失敗しました。どのように診断して解決しますか？", "options": {"A": "サポートに連絡", "B": "RDSイベントとCloudWatchメトリクスを確認し、十分なバックアップストレージスペースを確保", "C": "手動バックアップ", "D": "バックアップを無効化"}, "answer": "B", "explanation": "RDSイベントサブスクリプションはバックアップ失敗の理由を記録します。一般的な原因にはストレージスペース不足やメンテナンスウィンドウの競合があり、設定を調整できます。"},
    {"id": "q16", "domain": 6, "question": "すべてのAPIリクエストが認証を通過することを確保する必要があります。API Gatewayをどのように設定しますか？", "options": {"A": "パブリックAPIを使用", "B": "API Gateway Authorizer（LambdaまたはCognito）を設定", "C": "VPCを使用", "D": "WAFを使用"}, "answer": "B", "explanation": "API GatewayはLambda Authorizer（カスタムロジック）とCognito Authorizer（ユーザープール統合）をサポートし、リクエストのIDトークンを検証します。"},
    {"id": "q17", "domain": 6, "question": "開発者が開発環境リソースにのみアクセスできるように制限する必要があります。タグでどのように実現しますか？", "options": {"A": "異なるアカウントを使用", "B": "ABACポリシーを使用してリソースタグに基づいてアクセスを制御", "C": "セキュリティグループを使用", "D": "VPCを使用"}, "answer": "B", "explanation": "ABAC（属性ベースのアクセス制御）ポリシーは条件を使用してリソースタグをチェックし、Environment=Devのリソースへのアクセスのみを許可できます。"},
    {"id": "q18", "domain": 6, "question": "VPC内のリソースがAWSサービスにアクセスする際に公共インターネットを経由しないようにする必要があります。どのように設定しますか？", "options": {"A": "NAT Gatewayを使用", "B": "VPC Endpoints（GatewayまたはInterfaceタイプ）を設定", "C": "Internet Gatewayを使用", "D": "VPNを使用"}, "answer": "B", "explanation": "VPC EndpointsはVPC内リソースがAWSプライベートネットワーク経由でサービスにアクセスすることを許可し、データは公共インターネットを経由せず、セキュリティとパフォーマンスが向上します。"},
    {"id": "q19", "domain": 1, "question": "CodePipelineでA/Bテストデプロイ戦略を実装する必要があります。どのように設計しますか？", "options": {"A": "2つのバージョンを同時にデプロイ", "B": "Lambdaエイリアス加重デプロイまたはALBターゲットグループ加重分配を使用", "C": "異なるパイプラインを使用", "D": "手動切り替え"}, "answer": "B", "explanation": "Lambdaエイリアス加重またはALBターゲットグループ加重はトラフィックを異なるバージョンに比例配分でき、A/Bテストを実現します。"},
    {"id": "q20", "domain": 1, "question": "デプロイ失敗時に関係するチームメンバーに通知する必要があります。CodePipelineでどのように実現しますか？", "options": {"A": "手動チェック", "B": "パイプライン通知ルールを設定してSNS/Slackに送信", "C": "CloudWatch Logsを使用", "D": "メールポーリング"}, "answer": "B", "explanation": "CodePipelineは通知ルールをサポートし、パイプライン状態変化（失敗など）時にSNSトピックに通知を送信でき、SNSはSlackなどの通信ツールと統合できます。"},
    {"id": "q21", "domain": 2, "question": "CloudFormationテンプレートでリソースのローリングアップデートを実装する必要があります。どのように設定しますか？", "options": {"A": "削除して再作成", "B": "UpdatePolicyでAutoScalingRollingUpdateを設定", "C": "手動更新", "D": "ネストスタックを使用"}, "answer": "B", "explanation": "ASGのUpdatePolicyはAutoScalingRollingUpdateを設定でき、バッチサイズと一時停止時間を指定して、インスタンスのローリングアップデートを実現します。"},
    {"id": "q22", "domain": 2, "question": "CloudFormation失敗時に通知を送信する必要があります。どのように設定しますか？", "options": {"A": "手動監視", "B": "スタックのNotificationARNsをSNSトピックに設定", "C": "CloudWatch Logsを使用", "D": "Lambdaでポーリング"}, "answer": "B", "explanation": "CloudFormationスタックはSNS通知を設定でき、スタックイベント（作成、更新、削除、失敗）発生時に通知を送信します。"},
    {"id": "q23", "domain": 3, "question": "データベースの誤削除を防ぐための削除保護を確保する必要があります。RDSをどのように設定しますか？", "options": {"A": "IAMポリシーを使用", "B": "RDS削除保護を有効化", "C": "セキュリティグループを使用", "D": "バックアップを使用"}, "answer": "B", "explanation": "RDS削除保護はコンソール、CLI、またはAPIでデータベースインスタンスの削除をブロックし、削除するには先に保護を無効化する必要があります。"},
    {"id": "q24", "domain": 3, "question": "コンテナ終了時に処理中のリクエストを優雅に完了する必要があります。ECSをどのように設定しますか？", "options": {"A": "即座に終了", "B": "TaskのstopTimeoutとアプリケーションのSIGTERMシグナル処理を設定", "C": "より大きなインスタンスを使用", "D": "より多くのコンテナを使用"}, "answer": "B", "explanation": "ECSはSIGTERMシグナルを送信してコンテナに終了を通知し、stopTimeoutは待機時間を定義し、アプリケーションはシグナルを処理して現在のリクエストを完了してから終了すべきです。"},
    {"id": "q25", "domain": 4, "question": "CloudWatchで複雑なマルチメトリクスダッシュボードを作成する必要があります。効率的に管理するにはどうすればよいですか？", "options": {"A": "手動作成", "B": "CloudWatch Dashboard JSON定義を使用してCloudFormationで管理", "C": "CLIコマンドを使用", "D": "毎回手動更新"}, "answer": "B", "explanation": "DashboardはJSONとして定義でき、CloudFormationで管理でき、バージョン管理と環境間の一貫性を実現します。"},
    {"id": "q26", "domain": 4, "question": "複数のマイクロサービス間で単一ユーザーリクエストを追跡する必要があります。どのように実現しますか？", "options": {"A": "ログ相関を使用", "B": "X-Ray SDKを使用してトレースヘッダーを伝播", "C": "CloudTrailを使用", "D": "手動相関"}, "answer": "B", "explanation": "X-Ray SDKはサービス間でトレースIDを伝播し、分散リクエストを単一のトレースに相関させ、完全なリクエストパスを可視化します。"},
    {"id": "q27", "domain": 5, "question": "EC2ステータスチェック失敗に自動対応する必要があります。どのように設定しますか？", "options": {"A": "手動再起動", "B": "EC2自動回復またはCloudWatchアラームアクションを設定", "C": "より大きなインスタンスを使用", "D": "ASGを使用"}, "answer": "B", "explanation": "EC2自動回復はステータスチェック失敗時に新しいハードウェアでインスタンスを自動回復するか、CloudWatchアラームのEC2アクションを使用して自動再起動/終了します。"},
    {"id": "q28", "domain": 5, "question": "複数のAWSアカウントで標準化されたインシデント対応フローを実行する必要があります。どのように実現しますか？", "options": {"A": "各アカウントで独立して処理", "B": "Systems Managerクロスアカウント自動化を使用", "C": "手動調整", "D": "メール通知を使用"}, "answer": "B", "explanation": "SSMはクロスアカウント自動化実行をサポートし、中央アカウントから複数のターゲットアカウントで標準化されたインシデント対応ドキュメントを実行できます。"},
    {"id": "q29", "domain": 6, "question": "IAMアクセスキーが漏洩または悪用されていないか検出する必要があります。どのように監視しますか？", "options": {"A": "定期的にローテーション", "B": "GuardDutyを使用して異常なAPI呼び出しパターンを検出", "C": "CloudWatchを使用", "D": "手動レビュー"}, "answer": "B", "explanation": "GuardDutyはCloudTrailログを分析して異常な動作（未知の場所からのAPI呼び出しや疑わしいAPI呼び出しパターンなど）を検出し、認証情報が漏洩した可能性を示します。"},
    {"id": "q30", "domain": 6, "question": "SSRF攻撃を防ぐためにEC2インスタンスメタデータサービスへのアクセスを制限する必要があります。どのように設定しますか？", "options": {"A": "メタデータサービスを無効化", "B": "IMDSv2を使用してセッショントークンを要求", "C": "セキュリティグループを使用", "D": "NACLを使用"}, "answer": "B", "explanation": "IMDSv2はメタデータをクエリする前にセッショントークンを取得する必要があり、SSRF攻撃の難易度が上がります。IMDSv2の使用を強制すべきです。"},
    {"id": "q31", "domain": 1, "question": "コード変更ごとにAPIドキュメントを自動更新する必要があります。CI/CDにどのように統合しますか？", "options": {"A": "手動更新", "B": "CodeBuildでコードからドキュメントを生成してS3/API Gatewayに公開", "C": "サードパーティツールを使用", "D": "ドキュメントを更新しない"}, "answer": "B", "explanation": "CodeBuildはドキュメント生成ツール（Swagger、OpenAPIなど）を実行でき、生成されたドキュメントをS3静的サイトに公開するかAPI Gatewayのドキュメントを更新できます。"},
    {"id": "q32", "domain": 2, "question": "CloudFormation更新時にリソースの物理名を保持する必要があります。どのように設定しますか？", "options": {"A": "名前を指定しない", "B": "リソース名属性を明示的に指定", "C": "インポート機能を使用", "D": "StackSetsを使用"}, "answer": "B", "explanation": "リソースがサポートし、名前属性（BucketNameなど）を明示的に指定した場合、CloudFormationはその名前を維持しますが、一部の更新ではリソースの置換が必要な場合があることに注意してください。"},
    {"id": "q33", "domain": 3, "question": "任意の数の同時リクエストを処理できるサーバーレスアーキテクチャを設計する必要があります。主要な考慮事項は？", "options": {"A": "固定容量を使用", "B": "Lambda同時実行制限、下流サービス容量、非同期処理に注意", "C": "より大きなメモリを使用", "D": "予約同時実行を使用"}, "answer": "B", "explanation": "Lambdaにはアカウントレベルの同時実行制限があり、下流サービス（RDSなど）がボトルネックになる可能性があります。予約同時実行、コネクションプール、SQSバッファリングなどの戦略を考慮すべきです。"},
    {"id": "q34", "domain": 4, "question": "CloudWatchダッシュボードにカスタムビジネスメトリクスを表示する必要があります。どのように実現しますか？", "options": {"A": "AWSメトリクスのみ表示可能", "B": "PutMetricData APIを使用してカスタムメトリクスを発行", "C": "ログを使用", "D": "サードパーティツールを使用"}, "answer": "B", "explanation": "アプリケーションはPutMetricData APIを使用してカスタムビジネスメトリクスをCloudWatchに発行でき、ダッシュボードで可視化できます。"},
    {"id": "q35", "domain": 5, "question": "Lambda関数の実行時間が突然増加した場合に調査をトリガーする必要があります。どのように自動化しますか？", "options": {"A": "手動監視", "B": "CloudWatchアラームでDurationメトリクスを監視し、SNS通知またはLambdaで調査をトリガー", "C": "タイムアウトを延長", "D": "X-Rayで手動分析"}, "answer": "B", "explanation": "Lambda Durationメトリクスは実行時間を表示し、ベースラインを超えた時にトリガーするアラームを設定でき、自動的にX-Ray分析または診断情報収集を開始できます。"},
    {"id": "q36", "domain": 6, "question": "S3バケットがパブリックアクセスに設定されないようにする必要があります。どのように強制しますか？", "options": {"A": "手動チェック", "B": "S3 Block Public Accessを有効にし、SCPで無効化を防止", "C": "バケットポリシーを使用", "D": "IAMポリシーを使用"}, "answer": "B", "explanation": "アカウントレベルのBlock Public Accessはすべてのパブリックアクセスをブロックし、SCPは管理者がこの設定を無効化することを防止でき、組織レベルの保護を実現します。"},
    {"id": "q37", "domain": 1, "question": "複数のマイクロサービスを同時にデプロイする際にバージョン互換性を調整する必要があります。CodePipelineでどのように実現しますか？", "options": {"A": "独立してデプロイ", "B": "パイプラインの並列アクションを使用して同時デプロイし、統合テストステージで検証", "C": "手動調整", "D": "メール通知を使用"}, "answer": "B", "explanation": "CodePipelineは並列アクションで複数サービスを同時デプロイすることをサポートし、後続ステージで統合テストを実行してサービス間の互換性を検証します。"},
    {"id": "q38", "domain": 2, "question": "既存のリソースをCloudFormation管理にインポートする必要があります。どのように実現しますか？", "options": {"A": "削除して再作成", "B": "CloudFormationリソースインポート機能を使用", "C": "手動同期", "D": "ネストスタックを使用"}, "answer": "B", "explanation": "CloudFormationリソースインポートは既存のAWSリソースをスタック管理に組み込むことを許可し、削除して再作成する必要がなく、リソースの継続性を維持します。"},
    {"id": "q39", "domain": 3, "question": "Spotインスタンス使用時に重要なワークロードの可用性を確保する必要があります。どのように設計しますか？", "options": {"A": "Spotを使用しない", "B": "On-DemandとSpotを混合使用し、Spot中断処理を設定", "C": "Spot価格を上げる", "D": "より大きなインスタンスを使用"}, "answer": "B", "explanation": "混合容量戦略はOn-Demandでベースライン容量を満たし、Spotで追加負荷を処理します。中断処理を設定して作業を他のインスタンスに移行できるようにします。"},
    {"id": "q40", "domain": 5, "question": "セキュリティインシデント後に根本原因分析を行う必要があります。証拠をどのように収集して保持しますか？", "options": {"A": "既存のログに依存", "B": "CloudTrailログ、VPC Flow Logs、EBSスナップショットを使用して証拠を保持", "C": "影響を受けたインスタンスを終了", "D": "最近のログのみ保持"}, "answer": "B", "explanation": "CloudTrailログを不変のS3ストレージで有効にし、VPC Flow Logsを保持し、フォレンジック分析用のEBSスナップショットを作成して、証拠の完全性を確保します。"}
  ]
}

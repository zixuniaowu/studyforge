{
  "exam": {
    "id": "dify-app-builder-set3-ja",
    "name": "Dify アプリビルダー 模擬試験 #3",
    "code": "DIFY-APPB",
    "provider": "Dify",
    "language": "ja",
    "description": "Dify アプリビルダー認定 - セット3",
    "totalQuestions": 50,
    "passingScore": 70,
    "examTime": 75,
    "domains": [
      { "id": 1, "name": "Chatbot Design", "weight": 25 },
      { "id": 2, "name": "Agent & Tools", "weight": 25 },
      { "id": 3, "name": "Workflow Orchestration", "weight": 25 },
      { "id": 4, "name": "Knowledge Base & RAG", "weight": 25 }
    ],
    "tags": ["Dify", "App Builder", "AI", "認定試験"]
  },
  "questions": [
    {"id": "q1", "domain": 1, "question": "Chatbotで長い会話を処理するための「コンテキスト圧縮」をどのように実装しますか？", "options": {"A": "すべての履歴を削除する", "B": "要約ノードを使用して会話履歴を圧縮し、重要な情報を保持する", "C": "会話のターン数を制限する", "D": "モデルのコンテキスト長を増やす"}, "answer": "B", "answerType": "single", "explanation": "コンテキスト圧縮の方法：\n- LLMを使用して会話履歴の要約を生成\n- 重要な情報と結論を保持\n- 圧縮戦略を動的に調整\n- 情報保持と効率のバランス", "difficulty": "hard"},
    {"id": "q2", "domain": 1, "question": "Chatbotの「マルチモーダル入力」処理をどのように設計しますか？", "options": {"A": "テキストのみサポート", "B": "画像、ファイル、音声など異なる入力タイプを識別して個別に処理する", "C": "すべての入力をテキストに変換", "D": "非テキスト入力を拒否"}, "answer": "B", "answerType": "single", "explanation": "マルチモーダル入力処理：\n- 入力タイプを識別（画像/ファイル/音声）\n- 対応する処理能力を使用\n- 複数の入力を組み合わせて総合的に理解可能\n- サポートする入力タイプを設定", "difficulty": "medium"},
    {"id": "q3", "domain": 1, "question": "Chatbotで「言語検出と切り替え」をどのように処理しますか？", "options": {"A": "単一言語のみサポート", "B": "ユーザーの言語を自動検出し、同じ言語で返信する", "C": "デフォルト言語を強制", "D": "ユーザーに手動選択させる"}, "answer": "B", "answerType": "single", "explanation": "言語検出と切り替え：\n- ユーザー入力言語を自動識別\n- 返信言語をユーザーと一致させる\n- プロンプトで言語ルールを設定可能\n- 多言語ナレッジベースをサポート", "difficulty": "medium"},
    {"id": "q4", "domain": 1, "question": "Chatbotの「会話ルーティング」をどのように実装しますか？", "options": {"A": "すべての質問を同じ方法で処理", "B": "質問タイプに基づいて異なる処理ロジックにルーティングする", "C": "ランダムに割り当て", "D": "時間で割り当て"}, "answer": "B", "answerType": "single", "explanation": "会話ルーティングの実装：\n- ユーザー質問のタイプや意図を識別\n- タイプに応じて対応する処理ロジックにルーティング\n- 人間のカスタマーサービスにルーティング可能\n- 複雑なルーティングルールをサポート", "difficulty": "medium"},
    {"id": "q5", "domain": 1, "question": "Chatbotで「予測的提案」をどのように実装しますか？", "options": {"A": "提案を提供しない", "B": "会話コンテキストに基づいてユーザーの次の質問を予測する", "C": "ランダムに質問を推奨", "D": "固定の質問のみ表示"}, "answer": "B", "answerType": "single", "explanation": "予測的提案の実装：\n- 現在の会話コンテキストを分析\n- ユーザーが関心を持つ可能性のある質問を予測\n- 関連質問のクイックオプションを提供\n- 会話効率を向上", "difficulty": "medium"},
    {"id": "q6", "domain": 2, "question": "Agentの「ツールチェーン」呼び出しをどのように実装しますか？", "options": {"A": "一度に1つのツールのみ使用可能", "B": "複数のツールを順番に連鎖させ、前の出力を次の入力として使用する", "C": "ランダムにツールを呼び出す", "D": "ユーザーが各ツールを手動で指定"}, "answer": "B", "answerType": "single", "explanation": "ツールチェーン呼び出し：\n- ツール間の依存関係を定義\n- 前のツールの出力を後続ツールに自動的に渡す\n- Agentが連鎖の必要性を自律的に決定\n- 中間結果の変換を処理", "difficulty": "hard"},
    {"id": "q7", "domain": 2, "question": "Agentで「ツールバージョン互換性」をどのように処理しますか？", "options": {"A": "バージョンを考慮しない", "B": "ツール説明でバージョン要件を示し、互換性処理を行う", "C": "最新バージョンのみ使用", "D": "互換性のないツールを無効化"}, "answer": "B", "answerType": "single", "explanation": "バージョン互換性の処理：\n- ツール説明でバージョン要件を説明\n- API呼び出し時にバージョンを指定\n- 異なるバージョンの戻り値に対して互換性を確保\n- ユーザーにバージョン変更を通知", "difficulty": "medium"},
    {"id": "q8", "domain": 2, "question": "Agentの「能動的な質問」能力をどのように設計しますか？", "options": {"A": "決して能動的に質問しない", "B": "情報が不足している場合、重要な情報をユーザーに積極的に確認する", "C": "すべての可能な情報を質問", "D": "エラー時のみ質問"}, "answer": "B", "answerType": "single", "explanation": "能動的な質問の設計：\n- タスクに必要な重要情報を識別\n- 情報が不足している場合は能動的に質問\n- フレンドリーな質問方法を設計\n- 過度な質問による体験への悪影響を回避", "difficulty": "medium"},
    {"id": "q9", "domain": 2, "question": "Agentで「ツール呼び出しリトライ」をどのように実装しますか？", "options": {"A": "失敗したら諦める", "B": "リトライ回数と間隔を設定し、一時的な失敗をインテリジェントに処理する", "C": "無限にリトライ", "D": "手動でリトライをトリガー"}, "answer": "B", "answerType": "single", "explanation": "ツール呼び出しリトライ：\n- 最大リトライ回数を設定\n- リトライ間隔を設定（増加可能）\n- リトライ可能なエラーとそうでないエラーを区別\n- リトライ失敗後のフォールバック処理", "difficulty": "medium"},
    {"id": "q10", "domain": 2, "question": "Agentの「ツール呼び出し頻度」をどのように制限しますか？", "options": {"A": "頻度を制限しない", "B": "呼び出し頻度制限を設定して乱用と超過を防止する", "C": "毎回1回のみ呼び出し可能", "D": "モデルが自動的に制御"}, "answer": "B", "answerType": "single", "explanation": "呼び出し頻度制限：\n- 単位時間あたりの呼び出し上限を設定\n- 制限に達した場合はキューイングまたは拒否\n- 異なるツールに異なる制限を設定\n- 呼び出し状況を記録して監視", "difficulty": "medium"},
    {"id": "q11", "domain": 3, "question": "Workflowで「動的ノード生成」をどのように実装しますか？", "options": {"A": "ノード数は固定", "B": "入力データに基づいて処理ノードを動的に生成する", "C": "手動でノードを追加", "D": "動的生成はサポートされていない"}, "answer": "B", "answerType": "single", "explanation": "動的ノード生成：\n- ループノードを使用して動的データを処理\n- データ量に応じて処理を自動的にスケール\n- バッチ操作をサポート\n- 並列度を動的に調整", "difficulty": "hard"},
    {"id": "q12", "domain": 3, "question": "Workflowで「ステートマシン」パターンをどのように実装しますか？", "options": {"A": "状態管理はサポートされていない", "B": "変数で状態を記録し、条件分岐で遷移を制御する", "C": "リニア実行のみ", "D": "外部ステートマシンが必要"}, "answer": "B", "answerType": "single", "explanation": "ステートマシンパターンの実装：\n- 変数で現在の状態を記録\n- 条件分岐で状態遷移を判断\n- 状態遷移ルールを定義\n- 状態遷移の副作用を処理", "difficulty": "hard"},
    {"id": "q13", "domain": 3, "question": "Workflowで「ノード依存関係の競合」をどのように処理しますか？", "options": {"A": "実行順序をランダムに選択", "B": "依存関係を分析して正しい実行順序を確保する", "C": "競合を無視", "D": "エラーを報告して停止"}, "answer": "B", "answerType": "single", "explanation": "依存関係競合の処理：\n- ノード依存関係グラフを構築\n- 循環依存を検出\n- トポロジカル順序で実行\n- 競合時に明確なプロンプトを提供", "difficulty": "medium"},
    {"id": "q14", "domain": 3, "question": "Workflowで「ブレークポイント継続実行」をどのように実装しますか？", "options": {"A": "毎回最初から開始", "B": "実行状態を保存し、失敗後にブレークポイントから復元可能", "C": "中断はサポートされていない", "D": "位置を手動で記録する必要がある"}, "answer": "B", "answerType": "single", "explanation": "ブレークポイント継続実行：\n- 各ノード実行後に状態を保存\n- 完了したノードを記録\n- 失敗時にブレークポイントから復元可能\n- 人的介入後の継続をサポート", "difficulty": "hard"},
    {"id": "q15", "domain": 3, "question": "Workflowで「ノード出力フォーマットの不一致」をどのように処理しますか？", "options": {"A": "直接エラーを報告", "B": "変換ノードまたはコードを使用してフォーマット変換を行う", "C": "不一致を無視", "D": "強制変換"}, "answer": "B", "answerType": "single", "explanation": "フォーマット不一致の処理：\n- コードノードでフォーマットを変換\n- テンプレートノードで文字列を処理\n- タイプ変換関数を提供\n- 入出力フォーマットを検証", "difficulty": "medium"},
    {"id": "q16", "domain": 4, "question": "ナレッジベースで「時間依存情報」をどのように処理しますか？", "options": {"A": "時効性を区別しない", "B": "コンテンツにタイムスタンプを付けて最新情報を優先的に返す", "C": "最新バージョンのみ保持", "D": "期限切れコンテンツを削除"}, "answer": "B", "answerType": "single", "explanation": "時間依存情報の処理：\n- コンテンツにタイムスタンプメタデータを追加\n- 検索時に時間要素を考慮\n- 最新の関連コンテンツを優先的に返す\n- 回答で情報の時効性を説明", "difficulty": "medium"},
    {"id": "q17", "domain": 4, "question": "ナレッジベースの「長文書処理」をどのように最適化しますか？", "options": {"A": "長文書を拒否", "B": "セマンティック完全性を保持しながらインテリジェントにチャンキングし、章索引を作成する", "C": "超過部分を切り捨て", "D": "コンテンツを圧縮"}, "answer": "B", "answerType": "single", "explanation": "長文書処理の最適化：\n- セマンティック境界でインテリジェントにチャンキング\n- 章構造情報を保持\n- 文書内索引を作成\n- チャンク間のコンテキスト関連性を維持", "difficulty": "medium"},
    {"id": "q18", "domain": 4, "question": "ナレッジベースで「マルチターン検索」をどのようにサポートしますか？", "options": {"A": "各ターンで独立して検索", "B": "会話コンテキストと組み合わせて後続の検索クエリを最適化する", "C": "最初のターンでのみ検索", "D": "ユーザーが手動で検索をトリガー"}, "answer": "B", "answerType": "single", "explanation": "マルチターン検索サポート：\n- 会話コンテキストを分析\n- 検索クエリを動的に調整\n- 検索条件を補完または細分化\n- 履歴検索結果と組み合わせ", "difficulty": "hard"},
    {"id": "q19", "domain": 4, "question": "ナレッジベースの「クロス言語検索」をどのように処理しますか？", "options": {"A": "単一言語のみサポート", "B": "多言語Embeddingまたは翻訳後検索を使用する", "C": "言語ごとにナレッジベースを分ける", "D": "ユーザーに元の言語でクエリを要求"}, "answer": "B", "answerType": "single", "explanation": "クロス言語検索の処理：\n- 多言語Embeddingモデルを使用\n- またはクエリを翻訳後に検索\n- またはドキュメントを翻訳後にインデックス作成\n- 言語の違いによるセマンティック偏差を処理", "difficulty": "hard"},
    {"id": "q20", "domain": 4, "question": "ナレッジベースで「階層検索」をどのように実装しますか？", "options": {"A": "すべてのコンテンツをフラットに検索", "B": "まずカテゴリ/トピックを検索し、次に具体的なコンテンツを検索する", "C": "最も詳細なレベルのみ検索", "D": "ユーザーが検索レベルを指定"}, "answer": "B", "answerType": "single", "explanation": "階層検索の実装：\n- コンテンツの階層構造を構築\n- まず関連カテゴリ/トピックを特定\n- 関連カテゴリ内で深く検索\n- 検索精度と効率を向上", "difficulty": "hard"},
    {"id": "q21", "domain": 1, "question": "Chatbotの「トピックメモリ」機能をどのように実装しますか？", "options": {"A": "トピックを記憶しない", "B": "セッション間でユーザーが議論したトピックを保存してパーソナライズされたサービスを提供する", "C": "現在のセッションのみ記憶", "D": "トピックを手動で保存"}, "answer": "B", "answerType": "single", "explanation": "トピックメモリ機能：\n- 会話から重要なトピックを抽出\n- セッション間で永続的に保存\n- 新しい会話で履歴トピックを関連付け\n- パーソナライズされた会話体験を提供", "difficulty": "medium"},
    {"id": "q22", "domain": 1, "question": "Chatbotの「入力サジェスト」機能をどのように設計しますか？", "options": {"A": "サジェストを提供しない", "B": "入力プレフィックスと会話履歴に基づいて補完提案を提供する", "C": "固定オプションを表示", "D": "入力完了後にのみ提案"}, "answer": "B", "answerType": "single", "explanation": "入力サジェスト機能：\n- ユーザー入力プレフィックスを分析\n- 履歴の高頻度入力と組み合わせ\n- リアルタイムで補完提案を提供\n- ユーザー入力を加速", "difficulty": "medium"},
    {"id": "q23", "domain": 2, "question": "Agentで「ツールが返す構造化データ」をどのように処理しますか？", "options": {"A": "生データを直接出力", "B": "構造化データを解析して自然言語で提示する", "C": "構造化データを無視", "D": "ユーザー自身に解析させる"}, "answer": "B", "answerType": "single", "explanation": "構造化データの処理：\n- JSON/XMLなどのフォーマットを解析\n- 重要な情報を抽出\n- 読みやすい自然言語に変換\n- 必要なデータの正確性を保持", "difficulty": "medium"},
    {"id": "q24", "domain": 2, "question": "Agentの「バッチ操作」能力をどのように設計しますか？", "options": {"A": "単一操作のみ", "B": "バッチリクエストを識別して複数の類似タスクを効率的に処理する", "C": "ユーザーが1つずつ送信", "D": "バッチリクエストを拒否"}, "answer": "B", "answerType": "single", "explanation": "バッチ操作の設計：\n- ユーザーのバッチ操作意図を識別\n- 類似タスクをマージして処理\n- 並列実行で効率を向上\n- バッチ結果を集約して表示", "difficulty": "medium"},
    {"id": "q25", "domain": 2, "question": "Agentで「段階的応答」をどのように実装しますか？", "options": {"A": "すべての処理が完了するまで応答しない", "B": "処理しながら中間結果を返し、最後に集約する", "C": "最終結果のみ返す", "D": "固定時間間隔で返す"}, "answer": "B", "answerType": "single", "explanation": "段階的応答の実装：\n- タスクを段階的に実行\n- 各段階完了時に中間状態を返す\n- ユーザーに処理進捗を知らせる\n- 最終的に完全な結果を返す", "difficulty": "medium"},
    {"id": "q26", "domain": 3, "question": "Workflowで「ノード実行タイムアウト」をどのように処理しますか？", "options": {"A": "無限に待機", "B": "ノードのタイムアウト時間を設定し、タイムアウト後にバックアップロジックを実行する", "C": "直接フローを終了", "D": "フロー全体を再起動"}, "answer": "B", "answerType": "single", "explanation": "ノード実行タイムアウト処理：\n- ノードに適切なタイムアウト時間を設定\n- タイムアウト後にリトライまたはスキップ可能\n- バックアップ処理ロジックを実行\n- ユーザーに通知またはログを記録", "difficulty": "medium"},
    {"id": "q27", "domain": 3, "question": "Workflowで「A/Bテスト」をどのように実装しますか？", "options": {"A": "A/Bテストはサポートされていない", "B": "条件分岐を使用して比率に基づいて異なる処理パスに分流する", "C": "バージョンを手動で選択", "D": "2回実行して比較"}, "answer": "B", "answerType": "single", "explanation": "A/Bテストの実装：\n- 条件分岐で比率に基づいて分流\n- 異なるパスで異なる戦略を使用\n- 各パスの実行結果を記録\n- 分析比較して最適なソリューションを選択", "difficulty": "medium"},
    {"id": "q28", "domain": 3, "question": "Workflowで「循環依存」をどのように処理しますか？", "options": {"A": "循環依存を許可", "B": "循環依存を検出し、設計時にエラーを表示する", "C": "実行時にエラーを報告", "D": "自動的にループを断つ"}, "answer": "B", "answerType": "single", "explanation": "循環依存の処理：\n- 設計時に循環を検出\n- ユーザーに依存関係の問題を表示\n- 無限ループ実行を防止\n- 修正提案を提供", "difficulty": "medium"},
    {"id": "q29", "domain": 3, "question": "Workflowで「条件付き待機」をどのように実装しますか？", "options": {"A": "待機はサポートされていない", "B": "待機条件を設定し、満たされた後に実行を継続する", "C": "固定時間待機のみ", "D": "手動で継続する必要がある"}, "answer": "B", "answerType": "single", "explanation": "条件付き待機の実装：\n- 満たすべき待機条件を定義\n- 条件状態をポーリングチェック\n- 最大待機時間を設定\n- 条件が満たされた後に実行を継続", "difficulty": "medium"},
    {"id": "q30", "domain": 3, "question": "Workflowで「マルチテナント分離」をどのようにサポートしますか？", "options": {"A": "すべてのテナントが共有", "B": "テナントごとにデータと実行環境を分離する", "C": "マルチテナントはサポートされていない", "D": "テナントを手動で切り替え"}, "answer": "B", "answerType": "single", "explanation": "マルチテナント分離：\n- テナントIDでデータを分離\n- 独立した実行コンテキスト\n- リソースクォータ制限\n- 権限分離", "difficulty": "medium"},
    {"id": "q31", "domain": 4, "question": "ナレッジベースで「テーブルデータ」をどのように処理しますか？", "options": {"A": "テーブルを無視", "B": "テーブル構造を解析し、テーブルコンテンツ検索をサポートする", "C": "プレーンテキストに変換", "D": "ヘッダーのみ抽出"}, "answer": "B", "answerType": "single", "explanation": "テーブルデータの処理：\n- テーブル構造を識別して解析\n- 行列関係を保持\n- テーブルコンテンツのセマンティック検索をサポート\n- 回答時にテーブル情報を正しく提示", "difficulty": "medium"},
    {"id": "q32", "domain": 4, "question": "ナレッジベースの「Q&Aペア」効果をどのように最適化しますか？", "options": {"A": "ドキュメントのみ保存", "B": "FAQ Q&Aペアを抽出または生成して正確なマッチングを向上させる", "C": "すべてのQ&Aを手動で追加", "D": "純粋なセマンティック検索に依存"}, "answer": "B", "answerType": "single", "explanation": "Q&Aペアの最適化：\n- ドキュメントからよくあるQ&Aを抽出\n- LLMを使用してQ&Aペアを生成\n- 質問マッチング時にFAQを優先的にマッチング\n- よくある質問の回答精度を向上", "difficulty": "medium"},
    {"id": "q33", "domain": 1, "question": "Chatbotで「インテリジェント修正」をどのように実装しますか？", "options": {"A": "修正しない", "B": "ユーザー入力の誤りを識別し、真の意図を理解する", "C": "ユーザーに再入力を要求", "D": "すべての入力を文字通り理解"}, "answer": "B", "answerType": "single", "explanation": "インテリジェント修正の実装：\n- スペルや文法のエラーを識別\n- ユーザーの真の意図を理解\n- 必要に応じて理解が正しいか確認\n- 小さなエラーによる誤解を回避", "difficulty": "medium"},
    {"id": "q34", "domain": 1, "question": "Chatbotの「会話リプレイ」機能をどのように設計しますか？", "options": {"A": "リプレイを提供しない", "B": "会話履歴を保存し、ユーザーが以前の会話を閲覧して継続できるようにする", "C": "最近の会話のみ保持", "D": "ファイルにエクスポート"}, "answer": "B", "answerType": "single", "explanation": "会話リプレイ機能：\n- 会話履歴を永続的に保存\n- 履歴会話リストを提供\n- 履歴会話から継続をサポート\n- 履歴コンテンツの検索が可能", "difficulty": "easy"},
    {"id": "q35", "domain": 2, "question": "Agentで「センシティブ操作確認」をどのように処理しますか？", "options": {"A": "すべての操作を直接実行", "B": "センシティブ操作を識別してユーザー確認を要求する", "C": "センシティブ操作を拒否", "D": "すべての操作を確認"}, "answer": "B", "answerType": "single", "explanation": "センシティブ操作確認：\n- センシティブ操作の範囲を定義\n- 実行前にユーザー確認を要求\n- 操作の影響を説明\n- 確認と実行ログを記録", "difficulty": "medium"},
    {"id": "q36", "domain": 2, "question": "Agentの「コンテキスト伝達」メカニズムをどのように設計しますか？", "options": {"A": "各呼び出しが独立", "B": "ツール呼び出し間で必要なコンテキスト情報を伝達する", "C": "すべての情報を伝達", "D": "ツール自身に取得させる"}, "answer": "B", "answerType": "single", "explanation": "コンテキスト伝達メカニズム：\n- ツールが必要とするコンテキストを識別\n- 呼び出し時に必要な情報を伝達\n- 冗長なデータ伝達を回避\n- コンテキストの一貫性を維持", "difficulty": "medium"},
    {"id": "q37", "domain": 3, "question": "Workflowで「グレースフルデグラデーション」をどのように実装しますか？", "options": {"A": "失敗即終了", "B": "コア機能が利用できない場合に自動的にバックアッププランに切り替える", "C": "エラーを無視して継続", "D": "回復を待つ"}, "answer": "B", "answerType": "single", "explanation": "グレースフルデグラデーションの実装：\n- コア機能と非コア機能を定義\n- コア機能のバックアッププランを準備\n- 失敗時に自動的に切り替え\n- ユーザーにデグラデーション状況を通知", "difficulty": "medium"},
    {"id": "q38", "domain": 3, "question": "Workflowで「フロー制御」をどのように実装しますか？", "options": {"A": "無制限に実行", "B": "並行制限とキューイングメカニズムを設定する", "C": "単一実行のみ許可", "D": "超過リクエストを拒否"}, "answer": "B", "answerType": "single", "explanation": "フロー制御の実装：\n- 最大並行数を設定\n- 並行数を超えた場合はキューに入れる\n- キュータイムアウトを設定可能\n- 監視とアラートメカニズム", "difficulty": "medium"},
    {"id": "q39", "domain": 4, "question": "ナレッジベースで「引用元追跡」をどのように処理しますか？", "options": {"A": "元を追跡しない", "B": "各チャンクの元を記録し、回答で引用を提供する", "C": "ドキュメント名のみ表示", "D": "原文にリンク"}, "answer": "B", "answerType": "single", "explanation": "引用元追跡：\n- チャンクに対応する元のドキュメントを記録\n- ページ番号または章情報を保存\n- 回答に引用元を表示\n- ユーザーが原文を確認できるようにサポート", "difficulty": "easy"},
    {"id": "q40", "domain": 4, "question": "ナレッジベースの「インデックス更新」効率をどのように最適化しますか？", "options": {"A": "毎回完全に再構築", "B": "増分更新で変更されたコンテンツのみ処理する", "C": "更新範囲を手動で決定", "D": "定期的に完全更新"}, "answer": "B", "answerType": "single", "explanation": "インデックス更新の最適化：\n- ドキュメントの変更を検出\n- 変更された部分のみ更新\n- インデックスを増分更新\n- 処理時間とリソースを削減", "difficulty": "medium"},
    {"id": "q41", "domain": 1, "question": "Chatbotで「同時進行する複数のセッション」をどのように処理しますか？", "options": {"A": "1つのセッションのみ許可", "B": "各セッションに独立したコンテキストを維持する", "C": "すべてのセッションコンテキストを共有", "D": "新しいセッションが古いセッションを上書き"}, "answer": "B", "answerType": "single", "explanation": "マルチセッション処理：\n- 各セッションに独立した識別子\n- 独立したコンテキスト状態を維持\n- セッション間の切り替えをサポート\n- リソースの適切な割り当て", "difficulty": "easy"},
    {"id": "q42", "domain": 1, "question": "Chatbotの「満足度収集」メカニズムをどのように設計しますか？", "options": {"A": "フィードバックを収集しない", "B": "適切なタイミングで評価を要求し、記録して分析する", "C": "毎回尋ねる", "D": "ネガティブなフィードバックのみ収集"}, "answer": "B", "answerType": "single", "explanation": "満足度収集メカニズム：\n- セッション終了時または問題解決後\n- シンプルな評価方法を提供\n- 評価と関連会話を記録\n- 分析して製品を改善", "difficulty": "easy"},
    {"id": "q43", "domain": 2, "question": "Agentで「ツール呼び出しの副作用」をどのように処理しますか？", "options": {"A": "副作用を無視", "B": "副作用を識別・追跡し、必要に応じてロールバックをサポートする", "C": "副作用のある操作を禁止", "D": "ユーザーに処理させる"}, "answer": "B", "answerType": "single", "explanation": "副作用の処理：\n- どの操作に副作用があるかを識別\n- 操作前の状態を記録\n- ロールバック能力を提供\n- ユーザーに副作用を明確に通知", "difficulty": "hard"},
    {"id": "q44", "domain": 2, "question": "Agentの「推論チェーン表示」をどのように設計しますか？", "options": {"A": "最終結果のみ表示", "B": "思考プロセスと決定根拠をユーザーに表示する", "C": "すべての推論を隠す", "D": "エラー時のみ表示"}, "answer": "B", "answerType": "single", "explanation": "推論チェーン表示：\n- Agentの思考プロセスを記録\n- 選択的にユーザーに表示\n- 結果の説明可能性を向上\n- ユーザーが決定を理解するのを支援", "difficulty": "medium"},
    {"id": "q45", "domain": 3, "question": "Workflowで「動的パラメータ伝達」をどのように実装しますか？", "options": {"A": "固定パラメータのみ", "B": "コンテキストまたは式からパラメータ値を動的に計算することをサポートする", "C": "各パラメータを手動入力", "D": "設定ファイルを使用"}, "answer": "B", "answerType": "single", "explanation": "動的パラメータ伝達：\n- 変数式を使用\n- コンテキストから値を取得\n- 計算と変換をサポート\n- 実行時に動的に解析", "difficulty": "medium"},
    {"id": "q46", "domain": 3, "question": "Workflowで「実行優先度」をどのように実装しますか？", "options": {"A": "すべてのタスクが同等の優先度", "B": "優先度キューを設定し、高優先度タスクを優先的に実行する", "C": "先着順で実行", "D": "ランダムに実行"}, "answer": "B", "answerType": "single", "explanation": "実行優先度：\n- タスクに優先度タグを設定\n- 優先度キューで管理\n- 高優先度タスクを優先的にスケジュール\n- 低優先度のスターベーションを防止", "difficulty": "medium"},
    {"id": "q47", "domain": 4, "question": "ナレッジベースで「マルチドキュメント関連」をどのように処理しますか？", "options": {"A": "各ドキュメントが独立", "B": "ドキュメント間の参照関係を構築して関連検索をサポートする", "C": "関連ドキュメントをマージ", "D": "関連を手動でマーク"}, "answer": "B", "answerType": "single", "explanation": "マルチドキュメント関連：\n- ドキュメント間の参照を識別\n- 関連グラフを構築\n- 検索時に関連ドキュメントを考慮\n- より完全な回答を提供", "difficulty": "hard"},
    {"id": "q48", "domain": 4, "question": "ナレッジベースの「ゼロショット検索」パフォーマンスをどのように最適化しますか？", "options": {"A": "大量のトレーニングデータが必要", "B": "事前学習済みの汎用Embeddingとプロンプトエンジニアリングを使用する", "C": "ゼロショット検索は不可能", "D": "検索品質要件を下げる"}, "answer": "B", "answerType": "single", "explanation": "ゼロショット検索の最適化：\n- 高品質な汎用Embeddingを選択\n- クエリプロンプトを最適化\n- 仮想ドキュメント埋め込み（HyDE）を使用\n- キーワードを組み合わせて検索を強化", "difficulty": "hard"},
    {"id": "q49", "domain": 1, "question": "Chatbotの「会話要約」機能をどのように実装しますか？", "options": {"A": "要約を提供しない", "B": "ユーザーが素早く振り返れるように会話要点の要約を自動生成する", "C": "重要点を手動でマーク", "D": "完全な会話をエクスポート"}, "answer": "B", "answerType": "single", "explanation": "会話要約機能：\n- 会話中の重要情報を識別\n- 構造化された要約を自動生成\n- 主な質問と解決策を含める\n- ユーザーが素早く振り返れるように便宜を図る", "difficulty": "medium"},
    {"id": "q50", "domain": 2, "question": "Agentで「長時間実行タスク」をどのように処理しますか？", "options": {"A": "同期的に完了を待つ", "B": "非同期実行し、進捗クエリと通知メカニズムを提供する", "C": "タイムアウトを設定して強制終了", "D": "小さなタスクに分割"}, "answer": "B", "answerType": "single", "explanation": "長時間タスクの処理：\n- タスクを非同期実行に変換\n- 進捗クエリインターフェースを提供\n- 完了後にユーザーに積極的に通知\n- キャンセルまたは中断をサポート", "difficulty": "medium"}
  ]
}

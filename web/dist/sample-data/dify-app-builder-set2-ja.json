{
  "exam": {
    "id": "dify-app-builder-set2-ja",
    "name": "Dify アプリビルダー 模擬試験 #2",
    "code": "DIFY-APPB",
    "provider": "Dify",
    "language": "ja",
    "description": "Dify アプリビルダー認定 - セット2",
    "totalQuestions": 50,
    "passingScore": 70,
    "examTime": 75,
    "domains": [
      { "id": 1, "name": "Chatbot Design", "weight": 25 },
      { "id": 2, "name": "Agent & Tools", "weight": 25 },
      { "id": 3, "name": "Workflow Orchestration", "weight": 25 },
      { "id": 4, "name": "Knowledge Base & RAG", "weight": 25 }
    ],
    "tags": ["Dify", "App Builder", "AI", "認定試験"]
  },
  "questions": [
    {"id": "q1", "domain": 1, "question": "Chatbotのエラーリカバリーメカニズムをどのように設計しますか？", "options": {"A": "すべてのエラーを無視する", "B": "エラーを検出し、フレンドリーなプロンプトを提供してユーザーに再表現を促す", "C": "直接会話を終了する", "D": "ログを記録するが処理しない"}, "answer": "B", "answerType": "single", "explanation": "エラーリカバリーメカニズムの設計：\n- モデルが返すエラーを検出\n- ユーザーにフレンドリーなエラープロンプトを提供\n- 問題を再表現する方法を提案\n- よくある質問オプションを提供可能", "difficulty": "medium"},
    {"id": "q2", "domain": 1, "question": "Chatbotでトピックガイダンスをどのように実装しますか？", "options": {"A": "ガイダンスは不要", "B": "プリセット質問と推奨返信でユーザーをガイドする", "C": "ユーザーの質問にのみ回答する", "D": "自動的に広告を送信する"}, "answer": "B", "answerType": "single", "explanation": "トピックガイダンスの実装：\n- 機能を紹介する開始メッセージを設定\n- プリセット質問オプションを提供\n- 回答後に関連質問を提案\n- 話題から外れた会話を識別してガイド", "difficulty": "easy"},
    {"id": "q3", "domain": 1, "question": "Chatbotの初回応答時間をどのように最適化しますか？", "options": {"A": "より大きなモデルを使用する", "B": "ストリーミング出力とウォームアップメカニズムを使用する", "C": "待機時間を増やす", "D": "すべての最適化をオフにする"}, "answer": "B", "answerType": "single", "explanation": "初回応答の最適化方法：\n- ストリーミング出力を有効にして待ち時間を軽減\n- モデルウォームアップでコールドスタート遅延を回避\n- 低遅延モデルを選択\n- ナレッジベース検索を最適化", "difficulty": "medium"},
    {"id": "q4", "domain": 1, "question": "Chatbotの「会話分析」機能はどのような情報を提供しますか？", "options": {"A": "メッセージ数のみ", "B": "ユーザー意図分布、よくある質問、満足度などの分析", "C": "モデル学習データ", "D": "競合分析"}, "answer": "B", "answerType": "single", "explanation": "会話分析機能：\n- ユーザー意図分布統計\n- よくある質問の識別\n- ユーザー満足度分析\n- 回答品質評価\n- 会話コンバージョン率分析", "difficulty": "easy"},
    {"id": "q5", "domain": 1, "question": "Chatbotの「フォールバック返信」をどのように設計しますか？", "options": {"A": "フォールバック返信を設定しない", "B": "回答できない場合、フレンドリーなガイダンスと代替案を提供する", "C": "単に「わかりません」と言う", "D": "前の返信を繰り返す"}, "answer": "B", "answerType": "single", "explanation": "フォールバック返信の設計：\n- 現在の質問に回答できないことを認める\n- 関連する可能性のある他の支援を提供\n- 別の方法で質問することを提案\n- 人間サービスへの転送オプションを提供可能", "difficulty": "medium"},
    {"id": "q6", "domain": 2, "question": "Agentの「能力境界」をどのように設計しますか？", "options": {"A": "Agentを万能にする", "B": "プロンプトで何ができて何ができないかを明確に定義する", "C": "境界を設定しない", "D": "モデル自身の判断に任せる"}, "answer": "B", "answerType": "single", "explanation": "能力境界の設計：\n- System Promptで能力範囲を明確にする\n- どのリクエストを拒否すべきかを定義\n- 境界問題に遭遇した場合の返信方法を指定\n- ユーザーフィードバックに基づいて定期的に調整", "difficulty": "medium"},
    {"id": "q7", "domain": 2, "question": "Agentのツール呼び出し順序をどのように制御しますか？", "options": {"A": "完全にランダム", "B": "プロンプトガイダンスとツール説明で決定に影響を与える", "C": "固定順序のみ", "D": "制御不可"}, "answer": "B", "answerType": "single", "explanation": "ツール呼び出し順序の制御：\n- プロンプトでワークフローを説明\n- ツール説明で依存関係を示す\n- Agentがタスク要件に基づいて自律的に決定\n- 説明で呼び出し条件を設定可能", "difficulty": "medium"},
    {"id": "q8", "domain": 2, "question": "Agentの「ツールタイムアウト」をどのように処理しますか？", "options": {"A": "無限に待機", "B": "タイムアウト時間を設定し、タイムアウト後にバックアップ戦略を採用", "C": "即座にエラー", "D": "プロセス全体を再起動"}, "answer": "B", "answerType": "single", "explanation": "ツールタイムアウト処理：\n- 各ツールに適切なタイムアウト時間を設定\n- タイムアウト後にリトライ可能\n- バックアッププランに切り替え可能\n- ユーザーに状況を説明", "difficulty": "medium"},
    {"id": "q9", "domain": 2, "question": "Agentは「曖昧な入力」をどのように処理しますか？", "options": {"A": "推測する", "B": "ユーザーに明確化を求めるか、オプションを提供する", "C": "入力を無視する", "D": "エラーを報告して終了"}, "answer": "B", "answerType": "single", "explanation": "曖昧な入力の処理：\n- 入力内の不確実な要素を識別\n- ユーザーに積極的に明確化を求める\n- 選択可能なオプションを提供\n- プロンプトで処理ルールを設定", "difficulty": "easy"},
    {"id": "q10", "domain": 2, "question": "Agentの「境界ケース」をどのようにテストしますか？", "options": {"A": "正常ケースのみテスト", "B": "異常入力、極端なケース、敵対的テストを設計する", "C": "ユーザーに問題を発見させる", "D": "テスト不要"}, "answer": "B", "answerType": "single", "explanation": "境界ケーステスト：\n- 空の入力と超長入力\n- 無関係なトピックと悪意のある入力\n- ツール呼び出し失敗シナリオ\n- 並行性とパフォーマンス圧力テスト", "difficulty": "medium"},
    {"id": "q11", "domain": 3, "question": "Workflowで「条件付き並行」をどのように処理しますか？", "options": {"A": "条件付き並行はサポートされていない", "B": "条件分岐の後に並列ノードを使用する", "C": "シリアル処理のみ", "D": "外部オーケストレーションが必要"}, "answer": "B", "answerType": "single", "explanation": "条件付き並行処理：\n- まず条件分岐で判断\n- 条件を満たす分岐は並列実行可能\n- 最後に結果を集約\n- シリアルと並列を柔軟に組み合わせ", "difficulty": "medium"},
    {"id": "q12", "domain": 3, "question": "Workflowで「データ変換」をどのように実装しますか？", "options": {"A": "データ変換不可", "B": "コードノードまたはテンプレート変換ノードを使用する", "C": "手動処理のみ", "D": "外部サービスに依存"}, "answer": "B", "answerType": "single", "explanation": "データ変換方法：\n- コードノードで複雑な変換\n- テンプレート変換ノードでフォーマット処理\n- JSON解析と構築\n- 変数抽出と組み合わせ", "difficulty": "easy"},
    {"id": "q13", "domain": 3, "question": "Workflowの「バージョン管理」をどのように実装しますか？", "options": {"A": "バージョン管理はサポートされていない", "B": "公開時にバージョンを作成し、履歴の表示をサポート", "C": "最新バージョンのみ保持", "D": "外部ツールが必要"}, "answer": "B", "answerType": "single", "explanation": "Workflowバージョン管理：\n- 公開ごとに新バージョンを作成\n- バージョン履歴を表示可能\n- バージョンロールバックをサポート\n- ドラフトと公開バージョンを分離", "difficulty": "easy"},
    {"id": "q14", "domain": 3, "question": "Workflowの「実行効率」をどのように最適化しますか？", "options": {"A": "より多くのノードを追加", "B": "独立したタスクを並列化し、不要なノードを削減", "C": "最も遅いモデルを使用", "D": "最適化不要"}, "answer": "B", "answerType": "single", "explanation": "実行効率の最適化：\n- 並列化可能な独立タスクを識別\n- 冗長なノードを削減\n- 適切なモデルを選択\n- ナレッジベース検索設定を最適化", "difficulty": "medium"},
    {"id": "q15", "domain": 3, "question": "Workflowでの「変数スコープ」をどのように管理しますか？", "options": {"A": "すべての変数はグローバルに利用可能", "B": "変数は定義ノード以降で利用可能、ノード出力を通じて渡される", "C": "変数は現在のノードでのみ有効", "D": "変数は使用不可"}, "answer": "B", "answerType": "single", "explanation": "変数スコープ管理：\n- 変数は定義ノード後に有効\n- ノード接続を通じて変数を渡す\n- 後続ノードで参照可能\n- 明確なデータフロー", "difficulty": "medium"},
    {"id": "q16", "domain": 4, "question": "ナレッジベースの「データ重複排除」をどのように処理しますか？", "options": {"A": "重複を処理しない", "B": "アップロード時に類似コンテンツを検出してマージする", "C": "重複を手動で削除", "D": "すべての重複を保持"}, "answer": "B", "answerType": "single", "explanation": "データ重複排除処理：\n- アップロード時に類似度検出\n- 重複または類似コンテンツを識別\n- マージまたはスキップを選択可能\n- ナレッジベースを整理整頓", "difficulty": "medium"},
    {"id": "q17", "domain": 4, "question": "ナレッジベースの「動的同期」をどのように設定しますか？", "options": {"A": "手動アップロードのみサポート", "B": "外部データソースに接続し、同期頻度を設定する", "C": "同期はサポートされていない", "D": "コードを書く必要がある"}, "answer": "B", "answerType": "single", "explanation": "動的同期設定：\n- Notion、Webページなどのデータソースに接続\n- 同期頻度を設定（手動/定期）\n- 同期範囲を設定\n- 同期状態を監視", "difficulty": "medium"},
    {"id": "q18", "domain": 4, "question": "ナレッジベースの「セマンティックマッチング」をどのように最適化しますか？", "options": {"A": "キーワードマッチングのみ使用", "B": "適切なEmbeddingモデルを選択しクエリを最適化する", "C": "セマンティックマッチングをオフにする", "D": "ドキュメント数を増やす"}, "answer": "B", "answerType": "single", "explanation": "セマンティックマッチングの最適化：\n- ドメインに適したEmbeddingモデルを選択\n- ユーザークエリを最適化（クエリ書き換え）\n- 類似度しきい値を調整\n- ハイブリッド検索で効果を向上", "difficulty": "medium"},
    {"id": "q19", "domain": 4, "question": "ナレッジベースで「専門用語」をどのように処理しますか？", "options": {"A": "用語を無視", "B": "用語集を作成し、チャンクでコンテキストを保持する", "C": "平易な言葉に翻訳", "D": "専門コンテンツを削除"}, "answer": "B", "answerType": "single", "explanation": "専門用語の処理：\n- 理解を助ける用語集を作成可能\n- チャンク時に用語の説明コンテキストを保持\n- プロンプトで用語の使用を説明\n- 関連する説明を同じチャンクに", "difficulty": "medium"},
    {"id": "q20", "domain": 4, "question": "ナレッジベースの「カバレッジ」をどのように評価しますか？", "options": {"A": "ドキュメント数のみ見る", "B": "ユーザー質問のマッチ率と回答できなかった質問を分析する", "C": "評価不可", "D": "ストレージ使用量を見る"}, "answer": "B", "answerType": "single", "explanation": "カバレッジ評価：\n- 質問マッチ成功率を統計\n- 回答できなかった質問を収集\n- 知識の空白領域を分析\n- 不足コンテンツを継続的に補充", "difficulty": "medium"},
    {"id": "q21", "domain": 1, "question": "Chatbotの「パーソナライズされた挨拶」をどのように実装しますか？", "options": {"A": "固定の挨拶を使用", "B": "ユーザー情報と時間に基づいて挨拶を動的に生成する", "C": "挨拶を使用しない", "D": "ランダムに挨拶を選択"}, "answer": "B", "answerType": "single", "explanation": "パーソナライズされた挨拶の実装：\n- ユーザー基本情報を取得\n- 時間に応じて適切な挨拶を選択\n- ユーザー名を参照可能\n- ユーザー履歴と組み合わせてカスタマイズ", "difficulty": "easy"},
    {"id": "q22", "domain": 1, "question": "Chatbotは「マルチターンフォローアップ」シナリオをどのように処理しますか？", "options": {"A": "毎回最初から開始", "B": "コンテキストを維持しフォローアップの意図を理解する", "C": "フォローアップを拒否", "D": "最初の質問にのみ回答"}, "answer": "B", "answerType": "single", "explanation": "マルチターンフォローアップ処理：\n- 会話コンテキストを維持\n- 代名詞と省略された参照を理解\n- 以前のQ&Aコンテンツを関連付け\n- 一貫性のある回答を提供", "difficulty": "medium"},
    {"id": "q23", "domain": 2, "question": "Agentの「タスク分解」能力をどのように設計しますか？", "options": {"A": "シンプルなタスクのみ処理", "B": "プロンプトで複雑なタスクをサブタスクに分解するよう導く", "C": "複雑なタスクを拒否", "D": "ユーザー自身に分解させる"}, "answer": "B", "answerType": "single", "explanation": "タスク分解の設計：\n- プロンプトで分解戦略を説明\n- モデルに複雑なタスクを識別させる\n- ステップごとにサブタスクを実行\n- サブタスク結果を集約", "difficulty": "hard"},
    {"id": "q24", "domain": 2, "question": "Agentは「ツールの競合」をどのように処理しますか？", "options": {"A": "ランダムにツールを選択", "B": "タスク要件に基づいて最適なツールを選択する", "C": "すべてのツールを同時に呼び出す", "D": "エラーを報告して終了"}, "answer": "B", "answerType": "single", "explanation": "ツール競合の処理：\n- 各ツールの用途を明確に定義\n- 説明で適用シナリオを示す\n- モデルが要件に基づいて選択を判断\n- 機能が重複するツールを避ける", "difficulty": "medium"},
    {"id": "q25", "domain": 2, "question": "Agentに「メモリ検索」機能をどのように追加しますか？", "options": {"A": "Agentにはメモリがない", "B": "会話履歴とナレッジベースを組み合わせて実装する", "C": "最後の1つだけ記憶可能", "D": "外部データベースが必要"}, "answer": "B", "answerType": "single", "explanation": "メモリ検索の実装：\n- 会話履歴を短期記憶として活用\n- ナレッジベースを長期知識ストレージとして\n- セッション変数に重要な情報を保存\n- 以前の会話内容を検索可能", "difficulty": "medium"},
    {"id": "q26", "domain": 3, "question": "Workflowで「非同期コールバック」をどのように処理しますか？", "options": {"A": "非同期はサポートされていない", "B": "待機ノードまたはポーリングで状態をチェックする", "C": "同期のみサポート", "D": "手動処理が必要"}, "answer": "B", "answerType": "single", "explanation": "非同期コールバック処理：\n- ポーリングで外部状態をチェック可能\n- タイムアウトとリトライメカニズムを設定\n- コールバック結果を処理\n- 長時間実行タスクをサポート", "difficulty": "hard"},
    {"id": "q27", "domain": 3, "question": "Workflowで「条件付きループ」をどのように実装しますか？", "options": {"A": "条件付きループはサポートされていない", "B": "ループノードと条件判断を組み合わせて使用する", "C": "固定回数ループのみ", "D": "外部制御が必要"}, "answer": "B", "answerType": "single", "explanation": "条件付きループの実装：\n- ループノードでデータを反復処理\n- ループ内部で条件判断\n- ループを早期に終了可能\n- ループ動作を柔軟に制御", "difficulty": "medium"},
    {"id": "q28", "domain": 3, "question": "Workflowの「入力検証」をどのように設定しますか？", "options": {"A": "入力を検証しない", "B": "開始ノードで変数タイプと必須項目を定義する", "C": "コードでのみ検証可能", "D": "ユーザーが入力の正確性を保証"}, "answer": "B", "answerType": "single", "explanation": "入力検証の設定：\n- 開始ノードで入力変数を定義\n- 変数タイプ制約を設定\n- 必須項目をマーク\n- デフォルト値を設定可能", "difficulty": "easy"},
    {"id": "q29", "domain": 3, "question": "Workflowの「実行状態」をどのように監視しますか？", "options": {"A": "監視不可", "B": "ログと実行履歴で状態を確認する", "C": "最終結果のみ確認可能", "D": "サードパーティツールが必要"}, "answer": "B", "answerType": "single", "explanation": "実行状態の監視：\n- 実行ログを確認\n- 各ノードの状態を追跡\n- 実行履歴を確認\n- エラーと例外を監視", "difficulty": "easy"},
    {"id": "q30", "domain": 3, "question": "Workflowで「大容量ファイル」をどのように処理しますか？", "options": {"A": "任意のサイズを直接処理", "B": "チャンク処理または外部ストレージを使用する", "C": "大容量ファイルを拒否", "D": "自動圧縮"}, "answer": "B", "answerType": "single", "explanation": "大容量ファイル処理：\n- 大容量ファイルをチャンク化\n- 外部ストレージを使用可能\n- ストリーム処理でメモリ使用量を削減\n- タイムアウト設定に注意", "difficulty": "medium"},
    {"id": "q31", "domain": 4, "question": "ナレッジベースの「リアルタイム性」をどのように向上させますか？", "options": {"A": "静的コンテンツのみ使用", "B": "自動同期と増分更新を設定する", "C": "毎日完全に再構築", "D": "更新不要"}, "answer": "B", "answerType": "single", "explanation": "リアルタイム性の向上：\n- データソース自動同期を設定\n- 完全更新ではなく増分更新を使用\n- 適切な同期頻度を設定\n- 更新状態を監視", "difficulty": "medium"},
    {"id": "q32", "domain": 4, "question": "ナレッジベースで「矛盾する情報」をどのように処理しますか？", "options": {"A": "すべての矛盾を保持", "B": "矛盾をマークし、最新または権威あるコンテンツを優先する", "C": "すべての矛盾を削除", "D": "ランダムに選択"}, "answer": "B", "answerType": "single", "explanation": "矛盾する情報の処理：\n- 矛盾の可能性があるコンテンツを識別\n- 情報のソースと時間をマーク\n- 権威または最新のコンテンツを優先\n- 回答で不確実性を説明可能", "difficulty": "hard"},
    {"id": "q33", "domain": 1, "question": "Chatbotの「シーン切り替え」をどのように設計しますか？", "options": {"A": "単一シーンのみサポート", "B": "ユーザー意図を識別して会話シーンを動的に切り替える", "C": "シーンを手動で選択", "D": "切り替えはサポートされていない"}, "answer": "B", "answerType": "single", "explanation": "シーン切り替えの設計：\n- ユーザー意図の変化を識別\n- 意図に応じて対応するシーンに切り替え\n- 関連コンテキストを維持またはクリア\n- スムーズな切り替え体験を提供", "difficulty": "hard"},
    {"id": "q34", "domain": 1, "question": "Chatbotは「感情認識」をどのように処理しますか？", "options": {"A": "ユーザーの感情を無視", "B": "ユーザーの感情を識別して返信のトーンを調整する", "C": "ネガティブな感情のみ検出", "D": "直接人間に転送"}, "answer": "B", "answerType": "single", "explanation": "感情認識の処理：\n- テキストから感情の手がかりを識別\n- 返信のトーンと方法を調整\n- ネガティブな感情に対してケアを示す\n- 極端な感情は特別な処理をトリガー可能", "difficulty": "medium"},
    {"id": "q35", "domain": 2, "question": "Agentの「応答品質」をどのように最適化しますか？", "options": {"A": "最も安いモデルを使用", "B": "プロンプトを最適化し、適切なモデルを選択し、ツール説明を完善する", "C": "ツール数を減らす", "D": "最適化不要"}, "answer": "B", "answerType": "single", "explanation": "応答品質の最適化：\n- System Promptを丁寧に設計\n- 能力にマッチするモデルを選択\n- ツール説明と例を完善\n- フィードバックに基づいて継続的に改善", "difficulty": "medium"},
    {"id": "q36", "domain": 2, "question": "Agentで「権限制御」をどのように処理しますか？", "options": {"A": "すべてのユーザーが同じ権限", "B": "ユーザーIDに基づいて利用可能なツールと機能を制限する", "C": "権限制御はサポートされていない", "D": "管理者のみ使用可能"}, "answer": "B", "answerType": "single", "explanation": "権限制御の実装：\n- ユーザーIDに基づいて識別\n- 利用可能なツール範囲を制御\n- センシティブな操作を制限\n- プロンプトで権限ルールを設定", "difficulty": "medium"},
    {"id": "q37", "domain": 3, "question": "Workflowで「定時トリガー」をどのように実装しますか？", "options": {"A": "組み込みタイマー", "B": "外部スケジューラと組み合わせてAPIでトリガーする", "C": "手動トリガーのみ", "D": "定時はサポートされていない"}, "answer": "B", "answerType": "single", "explanation": "定時トリガーの実装：\n- 外部スケジューラ（Cronなど）を使用\n- APIを通じてWorkflowをトリガー\n- 必要なパラメータを渡す\n- 実行結果を処理", "difficulty": "medium"},
    {"id": "q38", "domain": 3, "question": "Workflowで「データキャッシュ」をどのように実装しますか？", "options": {"A": "毎回再取得", "B": "変数で中間結果を保存し、重複計算を削減する", "C": "キャッシュはサポートされていない", "D": "外部キャッシュのみ"}, "answer": "B", "answerType": "single", "explanation": "データキャッシュの実装：\n- 変数で計算結果を保存\n- 同じ操作の重複呼び出しを回避\n- 条件分岐で再利用可能\n- データの時効性に注意", "difficulty": "medium"},
    {"id": "q39", "domain": 4, "question": "ナレッジベースの「フォーマット多様性」をどのように処理しますか？", "options": {"A": "1つのフォーマットのみサポート", "B": "複数のフォーマットをサポートし統一的に解析する", "C": "プレーンテキストに変換", "D": "非標準フォーマットを拒否"}, "answer": "B", "answerType": "single", "explanation": "フォーマット多様性の処理：\n- PDF、Word、Markdownなどをサポート\n- 異なるフォーマットを自動解析\n- テキストと構造情報を抽出\n- 統一処理後にインデックス作成", "difficulty": "easy"},
    {"id": "q40", "domain": 4, "question": "ナレッジベースで「権限分離」をどのようにサポートしますか？", "options": {"A": "すべての人がすべてのコンテンツを閲覧可能", "B": "ナレッジベースまたはドキュメントごとにアクセス権限を設定する", "C": "権限はサポートされていない", "D": "管理者のみ閲覧可能"}, "answer": "B", "answerType": "single", "explanation": "権限分離の実装：\n- 異なるナレッジベースに異なる権限を設定\n- ドキュメントレベルのアクセス制御\n- ユーザーIDと組み合わせて結果をフィルタリング\n- マルチテナントシナリオをサポート", "difficulty": "medium"},
    {"id": "q41", "domain": 1, "question": "Chatbotの「セッションタイムアウト」処理をどのように設計しますか？", "options": {"A": "タイムアウトなし", "B": "長時間非アクティブを検出してフレンドリーにセッションを終了する", "C": "即座に終了", "D": "通知を送信"}, "answer": "B", "answerType": "single", "explanation": "セッションタイムアウト処理：\n- 適切なタイムアウト時間を設定\n- タイムアウト前にリマインダーを送信\n- タイムアウト後にフレンドリーにセッションを終了\n- 復元のためにセッション状態を保存", "difficulty": "easy"},
    {"id": "q42", "domain": 1, "question": "Chatbotは「重複した質問」をどのように処理しますか？", "options": {"A": "毎回再計算", "B": "重複した質問を識別して素早く返信またはキャッシュを使用する", "C": "回答を拒否", "D": "すでに質問されたことをユーザーに伝える"}, "answer": "B", "answerType": "single", "explanation": "重複した質問の処理：\n- 類似または同一の質問を識別\n- キャッシュされた回答を直接返却可能\n- より詳細な説明が必要か尋ねる\n- 計算リソースを節約", "difficulty": "medium"},
    {"id": "q43", "domain": 2, "question": "Agentの「学習フィードバック」メカニズムをどのように設計しますか？", "options": {"A": "Agentは学習できない", "B": "ユーザーフィードバックを収集してプロンプトとツール設定を最適化する", "C": "モデルを自動更新", "D": "ログを記録するのみ"}, "answer": "B", "answerType": "single", "explanation": "学習フィードバックメカニズム：\n- ユーザー満足度フィードバックを収集\n- 失敗ケースを分析\n- プロンプト設計を最適化\n- ツール設定を調整\n- 継続的に反復改善", "difficulty": "medium"},
    {"id": "q44", "domain": 2, "question": "Agentは「並行タスク」をどのように処理しますか？", "options": {"A": "シリアル処理のみ", "B": "独立したサブタスクを識別して並列実行する", "C": "マルチタスクを拒否", "D": "ランダムに実行"}, "answer": "B", "answerType": "single", "explanation": "並行タスク処理：\n- 並列化可能なサブタスクを識別\n- 複数のツールを同時に呼び出す\n- 並列結果を集約\n- 処理効率を向上", "difficulty": "hard"},
    {"id": "q45", "domain": 3, "question": "Workflowの「エラー通知」をどのように設計しますか？", "options": {"A": "エラーを通知しない", "B": "エラー時に指定チャネルに通知を送信するよう設定する", "C": "ログを記録するのみ", "D": "自動リトライで通知しない"}, "answer": "B", "answerType": "single", "explanation": "エラー通知の設計：\n- エラートリガー条件を設定\n- 通知チャネルを選択（メール、Webhookなど）\n- エラー詳細を含める\n- タイムリーな対応を容易に", "difficulty": "easy"},
    {"id": "q46", "domain": 3, "question": "Workflowで「センシティブデータ」をどのように処理しますか？", "options": {"A": "センシティブデータを処理しない", "B": "ログでマスキングし、転送時に暗号化する", "C": "平文で保存", "D": "センシティブデータを含むリクエストを拒否"}, "answer": "B", "answerType": "single", "explanation": "センシティブデータ処理：\n- ログでマスキング\n- 転送時に暗号化を使用\n- 変数に長期保存を避ける\n- データ保護規制に準拠", "difficulty": "medium"},
    {"id": "q47", "domain": 4, "question": "ナレッジベースの「検索多様性」をどのように最適化しますか？", "options": {"A": "最も類似したもののみ返す", "B": "多様性アルゴリズムを使用して結果が集中しすぎないようにする", "C": "ランダムに返す", "D": "すべての結果を返す"}, "answer": "B", "answerType": "single", "explanation": "検索多様性の最適化：\n- MMRなどの多様性アルゴリズムを使用\n- 過度に類似した結果の返却を回避\n- より多くの関連する視点をカバー\n- より包括的な情報を提供", "difficulty": "hard"},
    {"id": "q48", "domain": 4, "question": "ナレッジベースで「否定情報」をどのように処理しますか？", "options": {"A": "肯定情報として扱う", "B": "否定セマンティクスを正しく理解し、検索と回答に反映する", "C": "否定語を無視", "D": "エラーを報告"}, "answer": "B", "answerType": "single", "explanation": "否定情報の処理：\n- Embeddingモデルが否定セマンティクスを理解\n- 検索時に否定関係を考慮\n- 回答で否定を正しく表現\n- ユーザーを誤解させないように", "difficulty": "hard"},
    {"id": "q49", "domain": 1, "question": "Chatbotの「段階的ガイダンス」をどのように設計しますか？", "options": {"A": "すべての機能を一度に表示", "B": "ユーザーの使用状況に応じて徐々により多くの機能を紹介する", "C": "ガイダンスを提供しない", "D": "ユーザーに学習を強制"}, "answer": "B", "answerType": "single", "explanation": "段階的ガイダンスの設計：\n- 新規ユーザーにはまずコア機能を表示\n- 使用状況に応じてより多くをアンロック\n- 適時に関連機能を推奨\n- 情報過負荷を避ける", "difficulty": "medium"},
    {"id": "q50", "domain": 2, "question": "Agentの「タスク完了率」をどのように評価しますか？", "options": {"A": "返信があるかどうかだけを見る", "B": "成功基準を定義し、タスク完了状況を統計する", "C": "ユーザー自身が判断", "D": "評価不要"}, "answer": "B", "answerType": "single", "explanation": "タスク完了率の評価：\n- 明確な成功基準を定義\n- 成功と失敗のタスクを統計\n- 失敗原因を分析\n- 継続的に最適化して完了率を向上", "difficulty": "medium"}
  ]
}

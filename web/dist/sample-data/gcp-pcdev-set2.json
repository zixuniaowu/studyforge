{
  "exam": {
    "id": "gcp-pcdev-set2",
    "name": "GCP 云开发工程师认证模拟考试 #2",
    "code": "PCDEV",
    "provider": "GCP",
    "language": "zh-CN",
    "description": "Google Cloud Professional Cloud Developer 认证考试模拟题",
    "totalQuestions": 40,
    "passingScore": 70,
    "examTime": 120,
    "domains": [
      {
        "id": 1,
        "name": "Designing highly scalable, available, and reliable cloud-native applications",
        "weight": 25
      },
      {
        "id": 2,
        "name": "Building and testing applications",
        "weight": 25
      },
      {
        "id": 3,
        "name": "Deploying applications",
        "weight": 20
      },
      {
        "id": 4,
        "name": "Integrating Google Cloud services",
        "weight": 20
      },
      {
        "id": 5,
        "name": "Managing application performance monitoring",
        "weight": 10
      }
    ],
    "tags": [
      "GCP",
      "Cloud Developer",
      "Cloud Run",
      "GKE",
      "认证考试"
    ]
  },
  "questions": [
    {
      "id": "q1",
      "domain": 1,
      "question": "一个应用需要处理突发流量，平时流量很低但偶尔会有大量请求。哪种架构最经济高效？",
      "options": {
        "A": "使用大型预留实例",
        "B": "使用 Cloud Run 或 Cloud Functions 的自动扩缩容",
        "C": "手动扩展 Compute Engine 实例",
        "D": "使用专用服务器"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "无服务器架构适合突发流量：\n- Cloud Run/Functions 自动扩缩容\n- 缩容到零时不产生费用\n- 按实际使用付费\n- 无需预估和预留容量",
      "difficulty": "medium"
    },
    {
      "id": "q2",
      "domain": 1,
      "question": "如何在微服务架构中实现服务发现？",
      "options": {
        "A": "硬编码服务地址",
        "B": "使用 Kubernetes Services 或 Cloud Service Directory",
        "C": "使用 IP 白名单",
        "D": "手动维护服务列表"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "服务发现解决方案：\n- Kubernetes Services：DNS 名称解析到 Pod\n- Cloud Service Directory：托管服务注册表\n- 支持健康检查和负载均衡\n- 动态更新无需代码修改",
      "difficulty": "medium"
    },
    {
      "id": "q3",
      "domain": 1,
      "question": "在设计 API 时，如何处理向后兼容性？",
      "options": {
        "A": "每次更新都创建新的 API",
        "B": "使用 API 版本控制（如 /v1/, /v2/）",
        "C": "强制所有客户端立即升级",
        "D": "不考虑兼容性"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "API 版本控制策略：\n- URL 路径版本（/v1/, /v2/）\n- 请求头版本\n- 支持多版本并行运行\n- 给客户端迁移时间\n- 逐步废弃旧版本",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "domain": 1,
      "question": "什么是 Saga 模式，它用于解决什么问题？",
      "options": {
        "A": "数据加密",
        "B": "分布式事务中跨服务的数据一致性",
        "C": "服务发现",
        "D": "负载均衡"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Saga 模式：\n- 将长事务拆分为一系列本地事务\n- 每个步骤有对应的补偿操作\n- 支持编排式和协调式两种实现\n- 最终一致性保证\n- 适用于微服务架构",
      "difficulty": "hard"
    },
    {
      "id": "q5",
      "domain": 1,
      "question": "如何设计一个支持多租户的 SaaS 应用？",
      "options": {
        "A": "为每个租户部署独立应用",
        "B": "使用共享基础设施，通过租户 ID 隔离数据",
        "C": "不进行隔离",
        "D": "使用物理服务器隔离"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "多租户设计模式：\n- 共享基础设施降低成本\n- 数据库行级或表级隔离\n- 使用租户上下文进行权限控制\n- 配额和限流按租户设置\n- 考虑数据加密和合规要求",
      "difficulty": "hard"
    },
    {
      "id": "q6",
      "domain": 1,
      "question": "CQRS（命令查询责任分离）模式的优势是什么？",
      "options": {
        "A": "减少代码量",
        "B": "分离读写模型，独立优化和扩展",
        "C": "简化数据库设计",
        "D": "减少网络延迟"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CQRS 优势：\n- 读写模型独立演进\n- 读侧可使用不同存储优化查询\n- 写侧专注于业务逻辑和一致性\n- 支持不同的扩展策略\n- 常与事件溯源结合使用",
      "difficulty": "hard"
    },
    {
      "id": "q7",
      "domain": 1,
      "question": "如何实现应用的健康检查？",
      "options": {
        "A": "不需要健康检查",
        "B": "提供 /health 端点返回应用和依赖的状态",
        "C": "只检查进程是否运行",
        "D": "手动检查"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "健康检查最佳实践：\n- Liveness probe：检查应用是否存活\n- Readiness probe：检查应用是否准备好接收流量\n- 检查数据库、缓存等依赖的连接\n- 返回详细状态信息便于诊断",
      "difficulty": "easy"
    },
    {
      "id": "q8",
      "domain": 1,
      "question": "在设计事件驱动系统时，如何处理消息顺序？",
      "options": {
        "A": "假设消息总是有序",
        "B": "使用消息分区键确保同一实体的消息有序处理",
        "C": "忽略顺序问题",
        "D": "使用全局锁"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "消息顺序处理：\n- Pub/Sub ordering key 确保同一 key 的消息有序\n- Kafka 使用分区保证分区内顺序\n- 设计幂等处理器应对重复消息\n- 考虑是否真的需要严格顺序",
      "difficulty": "medium"
    },
    {
      "id": "q9",
      "domain": 2,
      "question": "什么是测试金字塔？底层应该包含什么类型的测试？",
      "options": {
        "A": "端到端测试",
        "B": "单元测试",
        "C": "性能测试",
        "D": "安全测试"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "测试金字塔：\n- 底层：大量单元测试（快速、低成本）\n- 中层：适量集成测试\n- 顶层：少量端到端测试（慢、高成本）\n- 单元测试覆盖边界情况和业务逻辑",
      "difficulty": "easy"
    },
    {
      "id": "q10",
      "domain": 2,
      "question": "在 Cloud Build 中，如何并行执行多个构建步骤？",
      "options": {
        "A": "无法并行",
        "B": "使用 waitFor 字段指定依赖关系",
        "C": "创建多个 cloudbuild.yaml",
        "D": "使用多个触发器"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Build 并行执行：\n- 使用 waitFor 指定前置步骤\n- waitFor: ['-'] 表示立即开始\n- 没有依赖的步骤可以并行\n- 优化构建时间",
      "difficulty": "medium"
    },
    {
      "id": "q11",
      "domain": 2,
      "question": "什么是契约测试（Contract Testing）？",
      "options": {
        "A": "测试用户界面",
        "B": "验证服务之间的 API 契约是否被正确实现",
        "C": "测试数据库性能",
        "D": "测试网络连接"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "契约测试：\n- 验证服务间的 API 契约\n- 消费者定义期望，提供者验证实现\n- 早期发现接口不兼容\n- 支持独立部署\n- 工具如 Pact 支持契约测试",
      "difficulty": "medium"
    },
    {
      "id": "q12",
      "domain": 2,
      "question": "如何使用 skaffold 进行本地 Kubernetes 开发？",
      "options": {
        "A": "只能用于生产部署",
        "B": "自动构建、推送和部署到本地 K8s 集群，支持热重载",
        "C": "只是一个日志工具",
        "D": "用于数据库管理"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Skaffold 功能：\n- 自动化本地 K8s 开发流程\n- 检测代码变更自动重建部署\n- 支持多种构建工具和部署方式\n- 与 minikube、kind 等本地集群集成\n- 简化开发到部署的循环",
      "difficulty": "medium"
    },
    {
      "id": "q13",
      "domain": 2,
      "question": "如何在 GCP 中实现 GitOps 工作流？",
      "options": {
        "A": "手动部署所有变更",
        "B": "使用 Config Sync 从 Git 仓库同步配置到 GKE",
        "C": "不使用版本控制",
        "D": "直接修改生产环境"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "GCP GitOps：\n- Config Sync 从 Git 同步 K8s 配置\n- Git 作为唯一真实来源\n- 声明式配置管理\n- 自动漂移检测和修复\n- 审计和回滚能力",
      "difficulty": "medium"
    },
    {
      "id": "q14",
      "domain": 2,
      "question": "什么是不可变基础设施（Immutable Infrastructure）？",
      "options": {
        "A": "基础设施永不改变",
        "B": "部署新版本时创建新资源，而非修改现有资源",
        "C": "使用物理服务器",
        "D": "手动配置服务器"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "不可变基础设施：\n- 服务器一旦创建不再修改\n- 更新时创建新实例替换旧实例\n- 避免配置漂移\n- 简化回滚\n- 容器和虚拟机镜像是实现方式",
      "difficulty": "medium"
    },
    {
      "id": "q15",
      "domain": 2,
      "question": "代码审查的最佳实践是什么？（选择两项）",
      "options": {
        "A": "跳过代码审查以加快交付",
        "B": "检查代码逻辑、安全性和性能问题",
        "C": "保持评审范围小而专注",
        "D": "只由高级工程师审查"
      },
      "answer": ["B", "C"],
      "answerType": "multiple",
      "explanation": "代码审查最佳实践：\n- 小而频繁的变更更容易审查\n- 检查功能、安全、性能、可维护性\n- 使用自动化工具辅助\n- 建设性的反馈\n- 团队成员都参与审查",
      "difficulty": "easy"
    },
    {
      "id": "q16",
      "domain": 2,
      "question": "什么是特性开关（Feature Flags）？",
      "options": {
        "A": "硬件开关",
        "B": "在运行时控制功能是否启用的配置",
        "C": "网络防火墙规则",
        "D": "数据库索引"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "特性开关优势：\n- 无需部署即可启用/禁用功能\n- 支持渐进式发布\n- A/B 测试\n- 快速回滚问题功能\n- 解耦部署和发布",
      "difficulty": "medium"
    },
    {
      "id": "q17",
      "domain": 3,
      "question": "GKE Autopilot 和 Standard 模式的区别是什么？",
      "options": {
        "A": "没有区别",
        "B": "Autopilot 自动管理节点，按 Pod 资源计费；Standard 需要管理节点",
        "C": "Standard 更便宜",
        "D": "Autopilot 不支持有状态应用"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "GKE 模式比较：\n- Autopilot：Google 管理节点，按 Pod 计费\n- Standard：用户管理节点池，按节点计费\n- Autopilot 降低运维负担\n- Standard 提供更多定制能力",
      "difficulty": "medium"
    },
    {
      "id": "q18",
      "domain": 3,
      "question": "如何在 Cloud Run 中处理长时间运行的任务？",
      "options": {
        "A": "Cloud Run 不支持长任务",
        "B": "使用 Cloud Run Jobs 或增加请求超时时间",
        "C": "使用同步 HTTP 调用",
        "D": "减少任务处理量"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Run 长任务处理：\n- Cloud Run Jobs：适合后台任务\n- 服务请求超时最长 60 分钟\n- 可以使用 Cloud Tasks 进行异步处理\n- 考虑任务拆分和并行化",
      "difficulty": "medium"
    },
    {
      "id": "q19",
      "domain": 3,
      "question": "什么是 Pod Disruption Budget (PDB)？",
      "options": {
        "A": "Pod 的费用预算",
        "B": "限制自愿中断时可以同时不可用的 Pod 数量",
        "C": "网络带宽限制",
        "D": "存储配额"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Pod Disruption Budget：\n- 保证高可用性的策略\n- 限制自愿中断（如节点升级）时不可用的 Pod 数\n- 指定 minAvailable 或 maxUnavailable\n- 防止所有 Pod 同时被驱逐",
      "difficulty": "medium"
    },
    {
      "id": "q20",
      "domain": 3,
      "question": "如何在 GKE 中实现 Pod 的反亲和性（Anti-Affinity）？",
      "options": {
        "A": "无法实现",
        "B": "使用 podAntiAffinity 配置确保 Pod 分布在不同节点",
        "C": "增加 Pod 副本数",
        "D": "使用单个节点"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Pod 反亲和性：\n- 确保 Pod 分布在不同节点/区域\n- 提高可用性\n- 避免单点故障\n- 可以是硬性（required）或软性（preferred）要求",
      "difficulty": "medium"
    },
    {
      "id": "q21",
      "domain": 3,
      "question": "App Engine Standard 和 Flexible 环境的区别是什么？",
      "options": {
        "A": "没有区别",
        "B": "Standard 使用沙箱运行时，Flexible 运行在容器中支持自定义运行时",
        "C": "Flexible 不支持自动扩展",
        "D": "Standard 更贵"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "App Engine 环境比较：\n- Standard：沙箱运行时，毫秒级扩展，支持缩容到零\n- Flexible：Docker 容器，分钟级扩展，自定义运行时\n- Standard 适合快速扩展的 Web 应用\n- Flexible 适合需要自定义依赖的应用",
      "difficulty": "medium"
    },
    {
      "id": "q22",
      "domain": 3,
      "question": "如何在 Kubernetes 中管理有状态应用的存储？",
      "options": {
        "A": "不使用持久化存储",
        "B": "使用 StatefulSet 和 PersistentVolumeClaim",
        "C": "使用临时存储",
        "D": "存储在 Pod 内存中"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "有状态应用存储：\n- StatefulSet 提供稳定的网络标识和存储\n- PersistentVolumeClaim 请求持久化存储\n- GKE 支持多种存储类型（SSD、标准磁盘）\n- 支持动态卷供应",
      "difficulty": "medium"
    },
    {
      "id": "q23",
      "domain": 3,
      "question": "什么是 Deployment 的 recreate 策略？",
      "options": {
        "A": "滚动更新",
        "B": "先删除所有旧 Pod，再创建新 Pod",
        "C": "保持一个旧 Pod",
        "D": "随机更新"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Recreate 策略：\n- 先终止所有现有 Pod\n- 然后创建新版本的 Pod\n- 会有短暂停机\n- 适合不能同时运行多版本的应用\n- 比滚动更新简单",
      "difficulty": "easy"
    },
    {
      "id": "q24",
      "domain": 3,
      "question": "如何限制 Pod 的资源使用？",
      "options": {
        "A": "无法限制",
        "B": "在 Pod 规格中设置 resources.requests 和 resources.limits",
        "C": "使用外部监控",
        "D": "手动终止超限 Pod"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Pod 资源管理：\n- requests：调度时考虑的资源量\n- limits：资源使用上限\n- CPU 限制导致节流\n- 内存限制超出可能导致 OOM Kill\n- 使用 LimitRange 设置默认值",
      "difficulty": "easy"
    },
    {
      "id": "q25",
      "domain": 4,
      "question": "如何使用 Cloud Functions 进行实时文件处理？",
      "options": {
        "A": "轮询文件系统",
        "B": "使用 Cloud Storage 触发器在文件上传时自动执行函数",
        "C": "手动调用函数",
        "D": "使用定时任务"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Functions 实时处理：\n- 监听 Cloud Storage 事件\n- 文件上传/修改/删除时触发\n- 常用于图像处理、数据转换\n- 与 Vision AI、Speech-to-Text 等集成",
      "difficulty": "easy"
    },
    {
      "id": "q26",
      "domain": 4,
      "question": "Eventarc 的主要功能是什么？",
      "options": {
        "A": "数据存储",
        "B": "统一的事件路由服务，将 GCP 事件路由到目标服务",
        "C": "负载均衡",
        "D": "身份认证"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Eventarc：\n- 统一事件路由\n- 支持 Cloud Audit Logs、Pub/Sub、第三方事件\n- 将事件路由到 Cloud Run、GKE、Workflows\n- 简化事件驱动架构",
      "difficulty": "medium"
    },
    {
      "id": "q27",
      "domain": 4,
      "question": "如何在应用中使用 Vision AI API 进行图像分析？",
      "options": {
        "A": "无法集成",
        "B": "使用客户端库调用 API，传递图像获取标签、文字等",
        "C": "只能在控制台使用",
        "D": "需要自己训练模型"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Vision AI 集成：\n- 使用官方客户端库\n- 支持标签检测、OCR、人脸检测等\n- 可以传递 Cloud Storage URI 或 base64 图像\n- 按 API 调用计费",
      "difficulty": "easy"
    },
    {
      "id": "q28",
      "domain": 4,
      "question": "Cloud Workflows 的用途是什么？",
      "options": {
        "A": "实时数据处理",
        "B": "编排多个 HTTP 服务和 GCP API 的无服务器工作流",
        "C": "容器编排",
        "D": "数据库管理"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Workflows：\n- 无服务器工作流编排\n- 使用 YAML 定义步骤\n- 支持条件、循环、错误处理\n- 调用 HTTP 端点和 GCP 服务\n- 按执行步骤计费",
      "difficulty": "medium"
    },
    {
      "id": "q29",
      "domain": 4,
      "question": "如何使用 BigQuery 客户端库执行查询？",
      "options": {
        "A": "只能使用控制台",
        "B": "使用客户端库提交查询作业并获取结果",
        "C": "必须使用 REST API",
        "D": "只支持同步查询"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "BigQuery 客户端库：\n- 支持多种语言（Python、Java、Go 等）\n- 提交查询并迭代结果\n- 支持参数化查询\n- 处理大结果集分页\n- 支持异步和同步模式",
      "difficulty": "easy"
    },
    {
      "id": "q30",
      "domain": 4,
      "question": "如何在 Cloud Run 服务之间进行安全通信？",
      "options": {
        "A": "使用公开端点",
        "B": "配置 IAM 权限并使用服务身份令牌认证",
        "C": "不需要认证",
        "D": "使用硬编码密钥"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Run 服务间认证：\n- 设置服务为"需要认证"\n- 调用方服务账号需要 Cloud Run Invoker 角色\n- 使用 ID 令牌进行请求认证\n- 支持 OIDC 身份验证",
      "difficulty": "medium"
    },
    {
      "id": "q31",
      "domain": 4,
      "question": "Apigee 和 Cloud Endpoints 的区别是什么？",
      "options": {
        "A": "没有区别",
        "B": "Apigee 是企业级 API 管理平台，功能更丰富；Endpoints 是轻量级解决方案",
        "C": "Endpoints 功能更多",
        "D": "Apigee 只支持内部 API"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Apigee vs Endpoints：\n- Apigee：完整的 API 生命周期管理\n- 包括开发者门户、货币化、高级分析\n- Endpoints：轻量级 API 网关\n- 基本的认证和监控\n- Apigee 适合大型企业",
      "difficulty": "medium"
    },
    {
      "id": "q32",
      "domain": 4,
      "question": "如何使用 Cloud Spanner 客户端库实现事务？",
      "options": {
        "A": "Spanner 不支持事务",
        "B": "使用读写事务 API，在事务中执行多个操作",
        "C": "只支持单行操作",
        "D": "使用外部事务管理器"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Spanner 事务：\n- 支持读写事务和只读事务\n- 自动处理锁和冲突\n- 支持跨表和跨区域事务\n- 提供强一致性保证\n- 使用 Mutation 批量写入",
      "difficulty": "medium"
    },
    {
      "id": "q33",
      "domain": 5,
      "question": "如何使用 Cloud Profiler 优化应用性能？",
      "options": {
        "A": "只能查看日志",
        "B": "收集 CPU 和内存使用数据，识别热点函数",
        "C": "只测试网络延迟",
        "D": "手动分析代码"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Profiler：\n- 持续分析生产负载\n- CPU、堆内存、线程分析\n- 火焰图可视化\n- 低开销（<5%）\n- 帮助发现性能瓶颈",
      "difficulty": "medium"
    },
    {
      "id": "q34",
      "domain": 5,
      "question": "什么是 OpenTelemetry，它与 GCP 如何集成？",
      "options": {
        "A": "一种编程语言",
        "B": "开源的可观测性框架，可导出数据到 Cloud Trace 和 Monitoring",
        "C": "数据库工具",
        "D": "网络协议"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "OpenTelemetry：\n- 厂商中立的可观测性标准\n- 统一的 traces、metrics、logs API\n- GCP 提供导出器\n- 减少厂商锁定\n- 支持多种语言",
      "difficulty": "medium"
    },
    {
      "id": "q35",
      "domain": 5,
      "question": "如何在 Cloud Logging 中创建日志路由？",
      "options": {
        "A": "无法路由日志",
        "B": "创建日志接收器将日志导出到 BigQuery、Cloud Storage 或 Pub/Sub",
        "C": "只能查看日志",
        "D": "手动复制日志"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "日志路由：\n- 创建 Sink 定义日志过滤器和目标\n- 导出到 BigQuery 进行分析\n- 导出到 Cloud Storage 进行归档\n- 导出到 Pub/Sub 进行实时处理\n- 支持排除过滤器减少存储",
      "difficulty": "medium"
    },
    {
      "id": "q36",
      "domain": 5,
      "question": "如何设置 Cloud Run 的自定义域名？",
      "options": {
        "A": "无法设置",
        "B": "在 Cloud Run 中映射域名并配置 DNS",
        "C": "只能使用默认域名",
        "D": "使用第三方服务"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Cloud Run 自定义域名：\n- 在控制台添加域名映射\n- Google 自动配置 SSL 证书\n- 更新 DNS 记录指向 Cloud Run\n- 支持通配符域名\n- 可以使用全局负载均衡获得更多功能",
      "difficulty": "easy"
    },
    {
      "id": "q37",
      "domain": 5,
      "question": "什么是结构化日志，为什么重要？",
      "options": {
        "A": "日志格式不重要",
        "B": "使用 JSON 格式记录日志，便于查询和分析",
        "C": "只使用纯文本",
        "D": "减少日志量"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "结构化日志：\n- JSON 格式易于解析\n- 支持丰富的查询过滤\n- 与 Cloud Logging 原生集成\n- 可以提取标签和字段\n- 便于创建指标和警报",
      "difficulty": "easy"
    },
    {
      "id": "q38",
      "domain": 5,
      "question": "如何在 Cloud Monitoring 中创建自定义仪表板？",
      "options": {
        "A": "只能使用预定义仪表板",
        "B": "添加图表、选择指标和过滤条件，自定义布局",
        "C": "无法创建",
        "D": "需要编写代码"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "自定义仪表板：\n- 添加多种图表类型\n- 选择 GCP 或自定义指标\n- 配置过滤器和聚合\n- 支持变量和模板\n- 可以共享和导出",
      "difficulty": "easy"
    },
    {
      "id": "q39",
      "domain": 1,
      "question": "什么是 Bulkhead 模式？",
      "options": {
        "A": "网络加密",
        "B": "将系统分割成隔离的组件，防止故障蔓延",
        "C": "数据压缩",
        "D": "缓存策略"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Bulkhead 模式：\n- 受船舱隔板启发\n- 隔离不同的连接池或线程池\n- 一个组件故障不影响其他\n- 配合断路器使用\n- 提高系统弹性",
      "difficulty": "hard"
    },
    {
      "id": "q40",
      "domain": 2,
      "question": "如何在 CI/CD 中实现漏洞扫描？",
      "options": {
        "A": "跳过安全检查",
        "B": "使用 Container Analysis 扫描容器镜像中的已知漏洞",
        "C": "手动检查代码",
        "D": "只在生产环境扫描"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CI/CD 安全扫描：\n- Container Analysis 扫描 OS 和包漏洞\n- 与 Artifact Registry 集成\n- 设置扫描策略\n- Binary Authorization 确保只部署经过扫描的镜像\n- 在 Cloud Build 中集成扫描步骤",
      "difficulty": "medium"
    }
  ]
}

{
  "exam": {
    "id": "dify-llmops-set3-ja",
    "name": "Dify LLMOps 模擬試験 #3",
    "code": "DIFY-OPS",
    "provider": "Dify",
    "language": "ja",
    "description": "Dify LLMOps 運用認定 - 第3セット",
    "totalQuestions": 50,
    "passingScore": 70,
    "examTime": 90,
    "domains": [
      { "id": 1, "name": "Enterprise Deployment", "weight": 25 },
      { "id": 2, "name": "Model Management", "weight": 20 },
      { "id": 3, "name": "Performance & Monitoring", "weight": 30 },
      { "id": 4, "name": "Security & API", "weight": 25 }
    ],
    "tags": ["Dify", "LLMOps", "DevOps", "認定試験"]
  },
  "questions": [
    {"id": "q1", "domain": 1, "question": "Difyエンタープライズデプロイメントで「ゼロダウンタイムアップグレード」を実現する方法は？", "options": {"A": "ダウンタイム後に迅速にアップグレード", "B": "ローリングアップデートまたはブルーグリーンデプロイ戦略を使用", "C": "メンテナンスウィンドウでアップグレード", "D": "ゼロダウンタイムは非対応"}, "answer": "B", "answerType": "single", "explanation": "ゼロダウンタイムアップグレードの実現：\n- Kubernetesローリングアップデート\n- ブルーグリーンデプロイでトラフィック切り替え\n- カナリアリリースで段階的検証\n- ヘルスチェックと連携してサービス可用性を確保", "difficulty": "hard"},
    {"id": "q2", "domain": 1, "question": "Difyの「Sandboxコード実行環境」はどのようにセキュリティを確保しますか？", "options": {"A": "すべてのコードを信頼", "B": "隔離コンテナで実行し、リソースとネットワークアクセスを制限", "C": "手動でコードをレビュー", "D": "ユーザーコードを実行しない"}, "answer": "B", "answerType": "single", "explanation": "Sandboxセキュリティメカニズム：\n- Dockerコンテナ分離\n- リソースクォータ制限（CPU/メモリ）\n- ネットワークアクセス制御\n- タイムアウト時の自動終了", "difficulty": "medium"},
    {"id": "q3", "domain": 1, "question": "Difyの「外部ベクトルデータベース」接続を設定する方法は？", "options": {"A": "内蔵ベクトルDBのみ使用可能", "B": "環境変数でベクトルデータベース接続情報を設定", "C": "ソースコードを修正", "D": "Webインターフェースで設定"}, "answer": "B", "answerType": "single", "explanation": "外部ベクトルデータベース設定：\n- Qdrant、Weaviate、Pineconeなどをサポート\n- .envで接続アドレスと認証を設定\n- コレクション/インデックス名を設定\n- 接続テストで可用性を確認", "difficulty": "medium"},
    {"id": "q4", "domain": 1, "question": "Dify本番環境で「ログ集中管理」を実現する方法は？", "options": {"A": "ローカルログを確認", "B": "ELK/Lokiなどの集中ログシステムにログ出力を設定", "C": "手動でログを収集", "D": "ログ管理は非対応"}, "answer": "B", "answerType": "single", "explanation": "ログ集中管理：\n- stdoutへのログ出力を設定\n- Fluentd/Filebeatで収集\n- ELKまたはLokiに送信\n- ログ検索と分析をサポート", "difficulty": "medium"},
    {"id": "q5", "domain": 1, "question": "Difyの「定期タスクスケジューリング」を設定する方法は？", "options": {"A": "外部cronを使用", "B": "Celery Beatで定期タスクを設定", "C": "定期タスクは非対応", "D": "手動トリガー"}, "answer": "B", "answerType": "single", "explanation": "定期タスク設定：\n- Celery Beatで定期タスクをスケジュール\n- タスク周期とパラメータを設定\n- Workerがタスクを実行\n- タスク実行状態を監視", "difficulty": "medium"},
    {"id": "q6", "domain": 2, "question": "Difyで「モデル呼び出しチェーントレーシング」を実装する方法は？", "options": {"A": "トレーシング不可", "B": "OpenTelemetryを統合してAPI呼び出しの全チェーンをトレース", "C": "ログを確認", "D": "手動記録"}, "answer": "B", "answerType": "single", "explanation": "呼び出しチェーントレーシング：\n- OpenTelemetry SDKを統合\n- 各モデル呼び出しを記録\n- レイテンシとエラーをトレース\n- 呼び出しチェーンを可視化", "difficulty": "hard"},
    {"id": "q7", "domain": 2, "question": "Difyで「モデル呼び出しタイムアウト」を設定する方法は？", "options": {"A": "設定不可", "B": "モデル設定でタイムアウト時間を設定", "C": "デフォルトタイムアウトを使用", "D": "コードにハードコード"}, "answer": "B", "answerType": "single", "explanation": "タイムアウト設定：\n- モデルプロバイダー設定で設定\n- 適切なタイムアウト時間を設定\n- 異なるモデルに異なるタイムアウトを設定可能\n- タイムアウト時にエラーを返す", "difficulty": "easy"},
    {"id": "q8", "domain": 2, "question": "Difyで「モデル出力フォーマット検証」を実装する方法は？", "options": {"A": "出力を検証しない", "B": "ワークフローに出力フォーマットチェックノードを追加", "C": "モデル出力を信頼", "D": "手動チェック"}, "answer": "B", "answerType": "single", "explanation": "出力フォーマット検証：\n- コードノードでJSONフォーマットを検証\n- 必須フィールドの存在を確認\n- データ型を検証\n- フォーマットエラー時にリトライまたはアラート", "difficulty": "medium"},
    {"id": "q9", "domain": 2, "question": "Difyで「モデルAPIキーローテーション」を管理する方法は？", "options": {"A": "手動でキーを更新", "B": "複数キー設定と自動ローテーションをサポート", "C": "固定キーを使用", "D": "キー管理は非対応"}, "answer": "B", "answerType": "single", "explanation": "APIキーローテーション：\n- 複数のAPIキーを設定\n- ロードバランシングラウンドロビンを有効化\n- 再起動なしで新しいキーを追加可能\n- キー期限切れを自動処理", "difficulty": "medium"},
    {"id": "q10", "domain": 2, "question": "Difyで「モデル降格戦略」を設定する方法は？", "options": {"A": "降格は非対応", "B": "バックアップモデルを設定し、メインモデル失敗時に自動切り替え", "C": "手動切り替え", "D": "サービス停止"}, "answer": "B", "answerType": "single", "explanation": "モデル降格戦略：\n- メインモデルとバックアップモデルを設定\n- エラー検出時に自動切り替え\n- 切り替え条件を設定可能\n- 降格イベントを記録", "difficulty": "medium"},
    {"id": "q11", "domain": 3, "question": "Difyで「API呼び出しメトリクス監視」を実装する方法は？", "options": {"A": "監視は非対応", "B": "Prometheusメトリクスを公開しアラートを設定", "C": "手動で統計", "D": "ログから推定"}, "answer": "B", "answerType": "single", "explanation": "APIメトリクス監視：\n- Prometheus形式のメトリクスを公開\n- QPS、レイテンシ、エラー率を記録\n- Grafanaダッシュボードを設定\n- アラート閾値を設定", "difficulty": "medium"},
    {"id": "q12", "domain": 3, "question": "Difyの「コールドスタート時間」を最適化する方法は？", "options": {"A": "最適化不可", "B": "ウォームアップメカニズムとコネクションプールを使用", "C": "サーバーを増やす", "D": "機能を減らす"}, "answer": "B", "answerType": "single", "explanation": "コールドスタート最適化：\n- アプリケーションウォームアッププローブ\n- データベースコネクションプールの事前確立\n- モデル接続の維持\n- キャッシュのウォームアップ", "difficulty": "medium"},
    {"id": "q13", "domain": 3, "question": "Difyで「リクエストスロットリングとサーキットブレーカー」を実装する方法は？", "options": {"A": "リクエストを制限しない", "B": "スロットリングルールとサーキットブレーカー閾値を設定", "C": "手動制御", "D": "外部ゲートウェイに依存"}, "answer": "B", "answerType": "single", "explanation": "スロットリングとサーキットブレーカーの実装：\n- 分/秒あたりのリクエスト制限を設定\n- サーキットブレーカーエラー率閾値を設定\n- 制限超過時に429を返す\n- サーキットブレーカー後は即時失敗", "difficulty": "hard"},
    {"id": "q14", "domain": 3, "question": "Difyアプリケーションの「Token消費ホットスポット」を分析する方法は？", "options": {"A": "分析不可", "B": "監視データから高消費のユーザーや機能を特定", "C": "推測", "D": "ユーザーに質問"}, "answer": "B", "answerType": "single", "explanation": "Token消費分析：\n- ユーザー/アプリ別に消費を統計\n- 高消費シナリオを特定\n- Prompt効率を分析\n- 高消費機能を最適化", "difficulty": "medium"},
    {"id": "q15", "domain": 3, "question": "Difyで「オートスケーリング」を実装する方法は？", "options": {"A": "手動でインスタンスを調整", "B": "Kubernetes HPAでメトリクスに基づいて自動スケール", "C": "固定インスタンス数", "D": "スケーリングは非対応"}, "answer": "B", "answerType": "single", "explanation": "オートスケーリング：\n- Kubernetes HPA設定\n- CPU/メモリ/カスタムメトリクスに基づく\n- 最小/最大レプリカ数を設定\n- 負荷変動に対応", "difficulty": "hard"},
    {"id": "q16", "domain": 4, "question": "Difyで「API呼び出し監査ログ」を実装する方法は？", "options": {"A": "監査を記録しない", "B": "すべてのAPI呼び出しの詳細を記録", "C": "エラーのみ記録", "D": "オプションで記録"}, "answer": "B", "answerType": "single", "explanation": "API監査ログ：\n- 呼び出し元IDを記録\n- リクエストとレスポンスを記録\n- 時刻とIPを記録\n- コンプライアンス監査をサポート", "difficulty": "medium"},
    {"id": "q17", "domain": 4, "question": "Difyで保存される「機密設定情報」を保護する方法は？", "options": {"A": "平文で保存", "B": "暗号化ストレージとキー管理サービスを使用", "C": "機密情報を保存しない", "D": "手動で暗号化"}, "answer": "B", "answerType": "single", "explanation": "機密設定の保護：\n- Kubernetes Secretを使用\n- Vaultなどのキー管理を統合\n- データベースフィールドの暗号化\n- アクセス制御と監査", "difficulty": "medium"},
    {"id": "q18", "domain": 4, "question": "Difyの「APIバージョン管理」を実装する方法は？", "options": {"A": "バージョン管理は非対応", "B": "URLパスまたはHeaderでAPIバージョンを区別", "C": "各バージョンを個別にデプロイ", "D": "自動でバージョンを選択"}, "answer": "B", "answerType": "single", "explanation": "APIバージョン管理：\n- URLパスにバージョン番号を含める（/v1/）\n- Headerでバージョンを指定\n- 後方互換性を維持\n- ドキュメントでバージョン差異を説明", "difficulty": "medium"},
    {"id": "q19", "domain": 4, "question": "Difyで「IPアクセス制御」を実装する方法は？", "options": {"A": "IP制御は非対応", "B": "ゲートウェイまたはリバースプロキシ層でホワイトリスト/ブラックリストを設定", "C": "Difyで設定", "D": "ファイアウォールを変更"}, "answer": "B", "answerType": "single", "explanation": "IPアクセス制御：\n- リバースプロキシ（Nginx）で設定\n- APIゲートウェイ層で制御\n- クラウドセキュリティグループで設定\n- アクセス元を柔軟に管理", "difficulty": "medium"},
    {"id": "q20", "domain": 4, "question": "Difyは「クロスサイトリクエストフォージェリ(CSRF)」をどのように処理しますか？", "options": {"A": "CSRF防御なし", "B": "CSRFトークン検証を使用", "C": "クロスオリジンを無効化", "D": "GETリクエストのみ許可"}, "answer": "B", "answerType": "single", "explanation": "CSRF防御：\n- CSRFトークンを生成・検証\n- SameSite Cookie属性\n- Referer/Originを検証\n- APIはトークン認証を使用", "difficulty": "medium"},
    {"id": "q21", "domain": 1, "question": "Difyで「マルチ環境設定管理」を実装する方法は？", "options": {"A": "各環境で個別に変更", "B": "環境変数と設定ファイルで環境を区別", "C": "設定をハードコード", "D": "マルチ環境は非対応"}, "answer": "B", "answerType": "single", "explanation": "マルチ環境設定：\n- 異なる.envファイルを使用\n- Kubernetes ConfigMap/Secret\n- 環境変数でオーバーライド\n- 設定センターで管理", "difficulty": "medium"},
    {"id": "q22", "domain": 1, "question": "Difyの「リバースプロキシ」設定を構成する方法は？", "options": {"A": "リバースプロキシは不要", "B": "NginxでSSL終端とロードバランシングを処理するよう設定", "C": "内蔵プロキシを使用", "D": "サービスを直接公開"}, "answer": "B", "answerType": "single", "explanation": "リバースプロキシ設定：\n- NginxでHTTPS/SSLを処理\n- 複数のバックエンドにロードバランシング\n- 静的リソースのキャッシュ\n- アクセスログを設定", "difficulty": "medium"},
    {"id": "q23", "domain": 1, "question": "Difyの「Workerサービス」をスケールする方法は？", "options": {"A": "スケール不可", "B": "Workerレプリカ数を増やしてより多くのタスクを処理", "C": "APIサービスを増やす", "D": "コードを最適化"}, "answer": "B", "answerType": "single", "explanation": "Workerスケーリング：\n- Celery Workerインスタンスを増やす\n- 同時タスク数を設定\n- タスクキュー設定を調整\n- キューバックログを監視", "difficulty": "medium"},
    {"id": "q24", "domain": 1, "question": "Difyの「データベース高可用性」を実現する方法は？", "options": {"A": "単一インスタンスで十分", "B": "PostgreSQLマスタースレーブレプリケーションと自動フェイルオーバーを設定", "C": "定期バックアップ", "D": "インメモリデータベースを使用"}, "answer": "B", "answerType": "single", "explanation": "データベース高可用性：\n- マスタースレーブストリーミングレプリケーション\n- 自動フェイルオーバー（Patroni）\n- コネクションプール設定\n- 定期的なバックアップ検証", "difficulty": "hard"},
    {"id": "q25", "domain": 1, "question": "Difyの「静的リソースデプロイ」を処理する方法は？", "options": {"A": "APIと一緒にデプロイ", "B": "分離デプロイし、CDNで高速化", "C": "静的リソースを使用しない", "D": "ローカルストレージ"}, "answer": "B", "answerType": "single", "explanation": "静的リソースデプロイ：\n- Webフロントエンドを独立デプロイ\n- CDNで高速化\n- キャッシュポリシーを設定\n- マルチリージョン配信をサポート", "difficulty": "medium"},
    {"id": "q26", "domain": 2, "question": "Difyで「モデルA/Bテスト」を実装する方法は？", "options": {"A": "手動切り替え", "B": "トラフィック配分比率を設定して比較テスト", "C": "1つのモデルのみ使用", "D": "テストは非対応"}, "answer": "B", "answerType": "single", "explanation": "モデルA/Bテスト：\n- 複数のモデルバージョンを設定\n- トラフィック配分比率を設定\n- 比較メトリクスを収集\n- 最適なモデルを選択", "difficulty": "medium"},
    {"id": "q27", "domain": 2, "question": "Difyで「モデルコンテキストオーバーフロー」を処理する方法は？", "options": {"A": "エラーで停止", "B": "自動切り捨てまたはユーザーに最適化を促す", "C": "オーバーフローを無視", "D": "強制送信"}, "answer": "B", "answerType": "single", "explanation": "コンテキストオーバーフロー処理：\n- 制限超過を検出\n- 履歴メッセージを自動切り捨て\n- ユーザーにPrompt最適化を促す\n- 適切なモデルを推奨", "difficulty": "medium"},
    {"id": "q28", "domain": 2, "question": "Difyの「モデル課金パラメータ」を設定する方法は？", "options": {"A": "デフォルト価格を使用", "B": "各モデルの入力/出力単価を設定", "C": "課金を気にしない", "D": "プロバイダー価格を使用"}, "answer": "B", "answerType": "single", "explanation": "課金パラメータ設定：\n- 1000トークンあたりの価格を設定\n- 入力と出力の価格を区別\n- 異なる通貨をサポート\n- コスト見積もりに使用", "difficulty": "easy"},
    {"id": "q29", "domain": 2, "question": "Difyで「モデルレスポンスキャッシュ」を実装する方法は？", "options": {"A": "レスポンスをキャッシュしない", "B": "同じクエリに対するレスポンス結果をキャッシュ", "C": "すべてをキャッシュ", "D": "ユーザーが自分でキャッシュ"}, "answer": "B", "answerType": "single", "explanation": "レスポンスキャッシュの実装：\n- クエリハッシュに基づいてキャッシュ\n- キャッシュTTLを設定\n- 重複呼び出しを削減\n- コストを節約", "difficulty": "medium"},
    {"id": "q30", "domain": 2, "question": "Difyで「Embeddingモデル選択」を管理する方法は？", "options": {"A": "1つに固定して使用", "B": "シナリオに応じて適切なEmbeddingモデルを選択", "C": "ランダムに選択", "D": "Embeddingを使用しない"}, "answer": "B", "answerType": "single", "explanation": "Embeddingモデル選択：\n- 言語サポートを考慮\n- ベクトル次元を評価\n- コストと効果のバランス\n- 検索精度をテスト", "difficulty": "medium"},
    {"id": "q31", "domain": 3, "question": "Difyで「分散トレーシング」を実装する方法は？", "options": {"A": "シングルマシンログ", "B": "Jaeger/Zipkinを統合してクロスサービス呼び出しをトレース", "C": "手動で関連付け", "D": "トレーシングは非対応"}, "answer": "B", "answerType": "single", "explanation": "分散トレーシング：\n- OpenTelemetryを統合\n- Trace IDを伝播\n- Spanデータを収集\n- Jaegerで可視化", "difficulty": "hard"},
    {"id": "q32", "domain": 3, "question": "Difyの「メモリリーク」を監視する方法は？", "options": {"A": "再起動で解決", "B": "メモリ使用傾向を監視して分析", "C": "メモリを監視しない", "D": "メモリを増やす"}, "answer": "B", "answerType": "single", "explanation": "メモリリーク監視：\n- メモリ使用を継続的に監視\n- 増加傾向を分析\n- プロファイラーで特定\n- リークを迅速に修正", "difficulty": "hard"},
    {"id": "q33", "domain": 3, "question": "Difyで「データベースクエリパフォーマンス」を最適化する方法は？", "options": {"A": "ハードウェアを増やす", "B": "クエリ文を最適化し適切なインデックスを追加", "C": "データを減らす", "D": "キャッシュで代替"}, "answer": "B", "answerType": "single", "explanation": "クエリパフォーマンス最適化：\n- スロークエリログを分析\n- 必要なインデックスを追加\n- SQL文を最適化\n- クエリ計画を分析", "difficulty": "medium"},
    {"id": "q34", "domain": 3, "question": "Difyの「タスクキュー監視」を設定する方法は？", "options": {"A": "キューを監視しない", "B": "キュー長と処理速度を監視", "C": "手動でチェック", "D": "ログを確認"}, "answer": "B", "answerType": "single", "explanation": "キュー監視設定：\n- Celeryキュー長を監視\n- タスク処理速度を統計\n- タスク失敗率を検出\n- バックログアラートを設定", "difficulty": "medium"},
    {"id": "q35", "domain": 3, "question": "Difyで「エラー集約分析」を実装する方法は？", "options": {"A": "エラーを1件ずつ確認", "B": "エラートラッキングサービスで類似エラーを集約", "C": "エラーを無視", "D": "手動で分類"}, "answer": "B", "answerType": "single", "explanation": "エラー集約分析：\n- Sentryなどのサービスを統合\n- 類似エラーを自動集約\n- エラー頻度を統計\n- 高頻度の問題を優先処理", "difficulty": "medium"},
    {"id": "q36", "domain": 4, "question": "Difyで「データ暗号化転送」を実装する方法は？", "options": {"A": "HTTP平文転送", "B": "全経路でHTTPS/TLS暗号化を使用", "C": "アプリケーション層で暗号化", "D": "オプションで暗号化"}, "answer": "B", "answerType": "single", "explanation": "データ暗号化転送：\n- TLS証明書を設定\n- HTTPSを強制\n- API通信を暗号化\n- データベース接続を暗号化", "difficulty": "medium"},
    {"id": "q37", "domain": 4, "question": "Difyの「セッション管理セキュリティ」を実装する方法は？", "options": {"A": "セキュリティ対策なし", "B": "安全なセッショントークンと有効期限メカニズム", "C": "セッションを平文で保存", "D": "有効期限なし"}, "answer": "B", "answerType": "single", "explanation": "セッション管理セキュリティ：\n- セッショントークンを安全に生成\n- 適切な有効期限を設定\n- HttpOnly Cookie\n- 強制ログアウトをサポート", "difficulty": "medium"},
    {"id": "q38", "domain": 4, "question": "Difyで「入力検証とサニタイズ」を処理する方法は？", "options": {"A": "すべての入力を信頼", "B": "入力形式を検証し危険なコンテンツをフィルタリング", "C": "形式のみ検証", "D": "検証しない"}, "answer": "B", "answerType": "single", "explanation": "入力検証サニタイズ：\n- 入力形式と型を検証\n- XSS/インジェクションコンテンツをフィルタリング\n- 入力長を制限\n- 異常入力を記録", "difficulty": "medium"},
    {"id": "q39", "domain": 4, "question": "Difyの「アクセス頻度制限」を設定する方法は？", "options": {"A": "頻度制限なし", "B": "分/時あたりのリクエスト上限を設定", "C": "外部制限に依存", "D": "手動でブロック"}, "answer": "B", "answerType": "single", "explanation": "頻度制限設定：\n- API Key/IPで制限\n- 時間ウィンドウと上限を設定\n- 制限超過時に429を返す\n- ホワイトリスト免除をサポート", "difficulty": "medium"},
    {"id": "q40", "domain": 4, "question": "Difyで「安全なファイルアップロード」を実装する方法は？", "options": {"A": "すべてのファイルを受け入れ", "B": "ファイルタイプ、サイズを検証し安全に保存", "C": "サイズのみ制限", "D": "アップロード禁止"}, "answer": "B", "answerType": "single", "explanation": "ファイルアップロードセキュリティ：\n- ファイルタイプを検証（ホワイトリスト）\n- ファイルサイズを制限\n- ウイルススキャン\n- 安全なストレージパス", "difficulty": "medium"},
    {"id": "q41", "domain": 1, "question": "Difyの「ヘルスチェックエンドポイント」を設定する方法は？", "options": {"A": "ヘルスチェックなし", "B": "内蔵の/healthエンドポイントでプローブ", "C": "自分で開発", "D": "サービスにping"}, "answer": "B", "answerType": "single", "explanation": "ヘルスチェック設定：\n- 内蔵/healthエンドポイント\n- データベース接続をチェック\n- Redis接続をチェック\n- ロードバランサープローブに使用", "difficulty": "easy"},
    {"id": "q42", "domain": 1, "question": "Difyの「設定ホットリロード」を処理する方法は？", "options": {"A": "再起動が必要", "B": "一部の設定は再起動なしでホットリロード可能", "C": "更新は非対応", "D": "すべてホットリロード"}, "answer": "B", "answerType": "single", "explanation": "設定ホットリロード：\n- モデル設定はホットリロード可能\n- アプリ設定は即時反映\n- システム設定は再起動が必要\n- 設定センターを使用", "difficulty": "medium"},
    {"id": "q43", "domain": 2, "question": "Difyで「モデルリクエストリトライ」を設定する方法は？", "options": {"A": "リトライしない", "B": "リトライ回数とバックオフ戦略を設定", "C": "手動リトライ", "D": "無限リトライ"}, "answer": "B", "answerType": "single", "explanation": "リクエストリトライ設定：\n- 最大リトライ回数を設定\n- バックオフ戦略を設定（指数バックオフ）\n- リトライ可能/不可能エラーを区別\n- リトライログを記録", "difficulty": "medium"},
    {"id": "q44", "domain": 2, "question": "Difyで「モデル同時実行制限」を処理する方法は？", "options": {"A": "同時実行を制限しない", "B": "セマフォまたはキューで同時呼び出し数を制御", "C": "シングルスレッド呼び出し", "D": "モデル制限に依存"}, "answer": "B", "answerType": "single", "explanation": "同時実行制限の処理：\n- 最大同時実行数を設定\n- セマフォで制御\n- リクエストキューイングメカニズム\n- プロバイダー制限のトリガーを回避", "difficulty": "medium"},
    {"id": "q45", "domain": 3, "question": "Difyの「アラート通知」を設定する方法は？", "options": {"A": "アラートは非対応", "B": "アラートルールと通知チャネルを設定", "C": "手動監視", "D": "メール通知"}, "answer": "B", "answerType": "single", "explanation": "アラート通知設定：\n- アラートルール（閾値）を設定\n- 通知チャネルを設定（メール/Slack/DingTalk）\n- アラートレベルを分類\n- アラートのミュートとエスカレーション", "difficulty": "medium"},
    {"id": "q46", "domain": 3, "question": "Difyで「ユーザー行動分析」を実装する方法は？", "options": {"A": "行動を分析しない", "B": "使用データを収集して分析", "C": "手動で統計", "D": "アンケート調査"}, "answer": "B", "answerType": "single", "explanation": "ユーザー行動分析：\n- ユーザー操作ログを記録\n- 機能使用頻度を分析\n- ユーザージャーニーをトラッキング\n- 製品体験を最適化", "difficulty": "medium"},
    {"id": "q47", "domain": 4, "question": "Difyの「データバックアップ検証」を実装する方法は？", "options": {"A": "バックアップのみで検証なし", "B": "定期的なリストアテストでバックアップの有効性を検証", "C": "ファイルサイズを確認", "D": "人による確認"}, "answer": "B", "answerType": "single", "explanation": "バックアップ検証方法：\n- 定期的にリストアテストを実行\n- データ完全性を検証\n- リストア時間を確認\n- 検証結果を記録", "difficulty": "hard"},
    {"id": "q48", "domain": 4, "question": "Difyの「機密データマスキング」を処理する方法は？", "options": {"A": "マスキングなし", "B": "ログと表示で機密情報を自動マスキング", "C": "手動マスキング", "D": "機密データを保存しない"}, "answer": "B", "answerType": "single", "explanation": "機密データマスキング：\n- APIキーをマスキング表示\n- ログで機密情報をフィルタリング\n- ユーザーデータをマスキング\n- マスキングルールを設定", "difficulty": "medium"},
    {"id": "q49", "domain": 1, "question": "Difyの「サービス依存関係チェック」を設定する方法は？", "options": {"A": "起動後にチェック", "B": "起動時にすべての依存サービスの可用性をチェック", "C": "依存関係をチェックしない", "D": "手動検証"}, "answer": "B", "answerType": "single", "explanation": "依存関係チェック設定：\n- 起動時にデータベース接続をチェック\n- Redis可用性を検証\n- ベクトルデータベースをチェック\n- 失敗時は起動をブロック", "difficulty": "medium"},
    {"id": "q50", "domain": 3, "question": "Difyで「コスト予算管理」を実装する方法は？", "options": {"A": "コスト管理なし", "B": "予算上限と使用アラートを設定", "C": "事後分析", "D": "使用を減らす"}, "answer": "B", "answerType": "single", "explanation": "コスト予算管理：\n- 月次予算上限を設定\n- 予算に近づいたらアラート\n- チーム/プロジェクト別に割り当て\n- 予算超過時に使用を制限", "difficulty": "medium"}
  ]
}

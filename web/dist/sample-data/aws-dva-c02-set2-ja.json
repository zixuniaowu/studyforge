{
  "exam": {
    "id": "aws-dva-c02-set2-ja",
    "name": "AWS DVA-C02 模擬試験 #2",
    "code": "DVA-C02",
    "provider": "AWS",
    "language": "ja",
    "description": "AWS認定デベロッパーアソシエイト試験模擬問題 - 第2套",
    "totalQuestions": 40,
    "passingScore": 72,
    "examTime": 130,
    "domains": [
      {
        "id": 1,
        "name": "AWSサービスによる開発",
        "weight": 32
      },
      {
        "id": 2,
        "name": "セキュリティ",
        "weight": 26
      },
      {
        "id": 3,
        "name": "デプロイ",
        "weight": 24
      },
      {
        "id": 4,
        "name": "トラブルシューティングと最適化",
        "weight": 18
      }
    ],
    "tags": [
      "AWS",
      "Developer",
      "Lambda",
      "認定試験"
    ]
  },
  "questions": [
    {
      "id": "q1",
      "domain": 1,
      "question": "開発者がAWS Lambdaを使用してAmazon Kinesis Data Streamsからのデータを処理しています。Lambda関数はデータを失うことなく失敗したレコードを処理する必要があります。どのように設定すべきですか？",
      "options": {
        "A": "失敗したレコードを処理するためにLambda宛先を設定する",
        "B": "バッチサイズを増やす",
        "C": "並列化係数を減らす",
        "D": "拡張ファンアウトを有効にする"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "Lambda宛先は失敗したレコードの処理方法を設定できます：\n- 失敗したレコードをSQS、SNS、または別のLambdaに送信\n- データ損失を防止\n- 後続の処理や調査を可能にする\n- BisectBatchOnFunctionErrorを設定してバッチを分割してリトライ可能\n\nバッチサイズの増加(B)は失敗の問題を解決しません。並列化係数(C)は並行性に影響します。拡張ファンアウト(D)は専用スループット用です。",
      "difficulty": "medium"
    },
    {
      "id": "q2",
      "domain": 1,
      "question": "開発者がDynamoDBでトランザクション操作を実装し、複数のアイテムの書き込みがすべて成功するか、すべて失敗することを保証する必要があります。どのAPIを使用すべきですか？",
      "options": {
        "A": "BatchWriteItem",
        "B": "TransactWriteItems",
        "C": "PutItem with ConditionExpression",
        "D": "UpdateItem"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "TransactWriteItemsはACIDトランザクションサポートを提供します：\n- 最大25件の書き込み操作\n- 原子性：すべて成功またはすべて失敗\n- テーブル間操作をサポート\n- 条件チェックを含む\n\nBatchWriteItem(A)は原子操作ではなく、一部のアイテムが失敗する可能性があります。PutItem(C)は単一アイテムのみを操作します。UpdateItem(D)も単一アイテムのみを操作します。",
      "difficulty": "medium"
    },
    {
      "id": "q3",
      "domain": 1,
      "question": "開発者がAmazon SQS標準キューを使用してメッセージを処理しています。アプリケーションは各メッセージが1回だけ処理されることを保証する必要があります。どのように実装すべきですか？",
      "options": {
        "A": "標準キューの代わりにFIFOキューを使用する",
        "B": "アプリケーションで冪等性処理を実装する",
        "C": "可視性タイムアウトを増やす",
        "D": "メッセージ保持期間を減らす"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "標準キューは重複メッセージを配信する可能性があり、アプリケーションには冪等性が必要です：\n- 一意の識別子を使用して処理済みメッセージを追跡\n- 処理状態をデータベースに保存\n- 同じメッセージの複数回処理で同じ結果を生成\n\nFIFOキュー(A)は正確に1回の処理を提供しますが、スループットに制限があります。可視性タイムアウト(C)と保持期間(D)は正確に1回の処理を保証しません。",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "domain": 1,
      "question": "開発者がAWS SDKを使用してDynamoDBテーブルをページネーションでクエリしています。各ページは1MBのデータを返します。すべての結果を取得するにはどの方法を使用すべきですか？",
      "options": {
        "A": "Query操作のLimitパラメータを使用する",
        "B": "LastEvaluatedKeyを確認し、空になるまでクエリを続ける",
        "C": "Queryの代わりにScan操作を使用する",
        "D": "読み取り容量ユニットを増やす"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "DynamoDBのページネーションはLastEvaluatedKeyを使用します：\n- 各Query/Scanは最大1MBのデータを返す\n- さらにデータがある場合、LastEvaluatedKeyを返す\n- 次のクエリのExclusiveStartKeyとして使用\n- LastEvaluatedKeyが空になるまで繰り返す\n\nLimit(A)はアイテム数を制限し、ページネーションではありません。Scan(C)は異なる操作タイプです。RCU(D)はページネーションに影響しません。",
      "difficulty": "medium"
    },
    {
      "id": "q5",
      "domain": 1,
      "question": "開発者がLambda関数から複数のダウンストリームサービスに通知を送信する必要があります。メッセージはSQSキュー、Lambda関数、HTTPエンドポイントに同時に送信する必要があります。どのサービスを使用すべきですか？",
      "options": {
        "A": "Amazon EventBridge",
        "B": "Amazon SNS",
        "C": "Amazon SQS",
        "D": "AWS Step Functions"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Amazon SNSはファンアウトをサポートするパブリッシュ/サブスクライブメッセージングサービスです：\n- 1つのメッセージを複数のサブスクライバーに送信\n- SQS、Lambda、HTTP/HTTPS、Emailなどのサブスクリプションタイプをサポート\n- パブリッシャーとサブスクライバーの分離\n- 高スループットと低レイテンシー\n\nEventBridge(A)はイベントルーティングに適しています。SQS(C)はポイントツーポイントキューです。Step Functions(D)はワークフローオーケストレーションです。",
      "difficulty": "medium"
    },
    {
      "id": "q6",
      "domain": 1,
      "question": "開発者がAPI GatewayとLambdaでREST APIを構築しています。バックエンド負荷を軽減するために特定のGETリクエストのレスポンスをキャッシュする必要があります。どのように設定すべきですか？",
      "options": {
        "A": "API Gatewayステージでキャッシュを有効にする",
        "B": "Lambda関数でキャッシュロジックを実装する",
        "C": "Amazon ElastiCacheを使用する",
        "D": "CloudFrontディストリビューションを設定する"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "API Gatewayは組み込みのレスポンスキャッシュを提供します：\n- ステージレベルで有効化と設定\n- メソッドごとにキャッシュ設定を構成\n- TTLを設定可能\n- Lambda呼び出し回数を削減\n\nこれはAPI Gatewayのネイティブ機能であり、追加のインフラストラクチャは不要です。ElastiCache(C)はアプリケーションキャッシュ用です。CloudFront(D)はエッジキャッシュ用です。",
      "difficulty": "medium"
    },
    {
      "id": "q7",
      "domain": 2,
      "question": "開発者がLambda関数のIAMポリシーを作成する必要があります。関数は特定のS3バケット内のオブジェクトを読み取る必要があります。最小権限の原則に従うポリシーはどれですか？",
      "options": {
        "A": "すべてのリソースにs3:*権限を付与する",
        "B": "特定のバケットARN/*にs3:GetObject権限を付与する",
        "C": "AmazonS3ReadOnlyAccessマネージドポリシーを付与する",
        "D": "すべてのS3バケットにs3:GetObject権限を付与する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "最小権限の原則は必要な権限のみを付与することを要求します：\n- s3:GetObjectはオブジェクトを読み取るために必要な唯一の権限\n- リソースを特定のバケットとそのオブジェクトに制限\n- ARNを使用してリソースを正確に指定\n\nワイルドカード権限(A,D)は広すぎます。マネージドポリシー(C)には不要な権限が含まれる可能性があります。",
      "difficulty": "medium"
    },
    {
      "id": "q8",
      "domain": 2,
      "question": "開発者がLambda関数でAPIキーを保存する必要があり、関数を再デプロイせずにキーを簡単に更新できる必要があります。どの方法を使用すべきですか？",
      "options": {
        "A": "Lambda環境変数を使用して暗号化を有効にする",
        "B": "AWS Systems Manager Parameter Storeを使用する",
        "C": "Lambdaレイヤーにキーをハードコーディングする",
        "D": "S3バケットに設定ファイルを保存する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Parameter Storeは設定とシークレットを保存するための理想的な選択です：\n- 暗号化されたSecureStringタイプをサポート\n- 関数とは独立してパラメータを更新可能\n- Lambdaは実行時に最新の値を読み取る\n- バージョン管理とアクセス制御\n\n環境変数(A)の更新には再デプロイが必要です。ハードコーディング(C)は安全ではありません。S3設定(D)は複雑さを増します。",
      "difficulty": "medium"
    },
    {
      "id": "q9",
      "domain": 2,
      "question": "開発者がLambdaベースのAPIを実装しています。呼び出し元のIAM権限に基づいて異なるデータを返す必要があります。呼び出し元のアイデンティティ情報を取得するにはどうすべきですか？",
      "options": {
        "A": "LambdaイベントオブジェクトのrequestContextから呼び出し元のアイデンティティを取得する",
        "B": "STS GetCallerIdentity APIを使用する",
        "C": "HTTPリクエストヘッダーから抽出する",
        "D": "Cognitoユーザープールを使用する"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "API Gatewayは呼び出し元のアイデンティティ情報をLambdaに渡します：\n- event.requestContext.identityに呼び出し元情報を含む\n- IAM認可の場合、userArn、accountIdなどを含む\n- 追加のAPI呼び出し不要\n- AWS_IAM認可タイプに適用\n\nSTS(B)はLambda自身のアイデンティティを返します。HTTPヘッダー(C)は偽装される可能性があります。Cognito(D)は別の認証方式です。",
      "difficulty": "medium"
    },
    {
      "id": "q10",
      "domain": 2,
      "question": "開発者がDynamoDBテーブル内の機密属性に特定のIAMロールのみがアクセスできるようにする必要があります。どのように実装すべきですか？",
      "options": {
        "A": "きめ細かいアクセス制御（FGAC）とIAMポリシー条件を使用する",
        "B": "機密データを保存する別のDynamoDBテーブルを作成する",
        "C": "クライアント側暗号化を使用する",
        "D": "DynamoDBリソースポリシーを設定する"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "きめ細かいアクセス制御は属性レベルの権限制御を可能にします：\n- IAMポリシーのCondition要素を使用\n- dynamodb:Attributes条件キーでアクセス可能な属性を制限\n- dynamodb:LeadingKeysでアクセス可能なアイテムを制限\n- DynamoDBとネイティブ統合\n\nテーブル分離(B)は複雑さを増します。クライアント側暗号化(C)はアクセスを制御しません。DynamoDBにはリソースポリシーがありません(D)。",
      "difficulty": "medium"
    },
    {
      "id": "q11",
      "domain": 3,
      "question": "開発者がAWS SAMを使用してサーバーレスアプリケーションをデプロイしています。デプロイが失敗した場合、自動的に前のバージョンにロールバックする必要があります。どのように設定すべきですか？",
      "options": {
        "A": "sam deploy --no-fail-on-empty-changesetを使用する",
        "B": "AutoPublishAliasとDeploymentPreferenceを設定する",
        "C": "CloudFormationロールバックトリガーを使用する",
        "D": "手動で複数のバージョンを維持する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "SAMのDeploymentPreferenceは安全なデプロイを有効にします：\n- AutoPublishAliasは新しいバージョンを自動的に公開しエイリアスを更新\n- DeploymentPreferenceはデプロイ戦略を設定（Canary、Linear、AllAtOnce）\n- CloudWatchアラームに基づく自動ロールバックをサポート\n- CodeDeployと統合\n\n他のオプションは自動安全デプロイとロールバック機能を提供しません。",
      "difficulty": "medium"
    },
    {
      "id": "q12",
      "domain": 3,
      "question": "開発チームがAWS CodePipelineとCodeBuildでCI/CDを行っています。ビルドプロセスはプライベートnpmレジストリにアクセスする必要があります。認証情報をどのように安全に保存すべきですか？",
      "options": {
        "A": "buildspec.ymlに認証情報をハードコーディングする",
        "B": "CodeBuild環境変数でSecrets Managerを参照する",
        "C": "ソースコードリポジトリに認証情報を保存する",
        "D": "ビルドコマンドで認証情報を渡す"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CodeBuildはSecrets Managerから安全に認証情報を取得できます：\n- 環境変数でSECRETS_MANAGERタイプを設定\n- 実行時に自動的にシークレット値を取得\n- 認証情報はログに公開されない\n- 自動ローテーションをサポート\n\nハードコーディング(A)とソースコード保存(C)は安全ではありません。コマンドでの受け渡し(D)はログに公開される可能性があります。",
      "difficulty": "medium"
    },
    {
      "id": "q13",
      "domain": 3,
      "question": "開発者がCloudFormationを使用してリソースをデプロイしています。スタック削除時に特定のリソース（S3バケットなど）を保持する必要があります。どの属性を使用すべきですか？",
      "options": {
        "A": "DependsOn",
        "B": "DeletionPolicy: Retain",
        "C": "UpdateReplacePolicy",
        "D": "Condition"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "DeletionPolicyはスタック削除時のリソースの動作を制御します：\n- Retain：リソースを保持し、削除しない\n- Delete：リソースを削除（デフォルト）\n- Snapshot：スナップショットを作成後に削除（特定のリソースに適用）\n\n重要なデータを誤って削除から保護するのに適しています。DependsOn(A)は作成順序を制御します。UpdateReplacePolicy(C)は更新置換を制御します。Condition(D)はリソース作成条件を制御します。",
      "difficulty": "medium"
    },
    {
      "id": "q14",
      "domain": 3,
      "question": "開発チームが複数のAWSアカウントに同じCloudFormationスタックをデプロイする必要があります。どの機能を使用すべきですか？",
      "options": {
        "A": "ネストされたスタック",
        "B": "CloudFormation StackSets",
        "C": "エクスポート/インポート",
        "D": "変更セット"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CloudFormation StackSetsはマルチアカウント/マルチリージョンデプロイをサポートします：\n- 単一テンプレートから複数のアカウントとリージョンにデプロイ\n- 集中管理と更新\n- AWS Organizations統合をサポート\n- 並列または順次デプロイオプション\n\nネストされたスタック(A)はモジュール化用です。エクスポート/インポート(C)はスタック間参照用です。変更セット(D)は変更プレビュー用です。",
      "difficulty": "medium"
    },
    {
      "id": "q15",
      "domain": 3,
      "question": "開発者がAWS CodeDeployを使用してLambda関数をデプロイしています。リスクを軽減するために新しいバージョンに徐々にトラフィックを移行する必要があります。どのデプロイ設定を使用すべきですか？",
      "options": {
        "A": "AllAtOnce",
        "B": "Linear10PercentEvery1Minute",
        "C": "Canary10Percent5Minutes",
        "D": "Immutable"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Linearデプロイは段階的なトラフィック移行を提供します：\n- 一定時間ごとに一定割合のトラフィックを増加\n- 例：Linear10PercentEvery1Minuteは毎分10%増加\n- 10分で完全なデプロイを完了\n- 問題発生時に迅速にロールバック可能\n\nAllAtOnce(A)は即座にすべてのトラフィックを切り替えます。Canary(C)は2段階で切り替えます。Immutable(D)はEC2デプロイタイプです。",
      "difficulty": "medium"
    },
    {
      "id": "q16",
      "domain": 4,
      "question": "開発者がLambda関数の同時実行数がアカウント制限に頻繁に達していることを発見しました。どのように対処すべきですか？",
      "options": {
        "A": "関数に予約済み同時実行を設定する",
        "B": "関数メモリを増やす",
        "C": "関数タイムアウトを減らす",
        "D": "SQSをバッファとして使用する"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "予約済み同時実行は関数に利用可能な同時実行クォータを保証します：\n- アカウント全体の同時実行から特定の関数に割り当て\n- 関数が常に利用可能な同時実行を確保\n- 関数の最大同時実行を制限することも可能\n- 他の関数がすべての同時実行を消費することを防止\n\nメモリ(B)とタイムアウト(C)は同時実行制限に影響しません。SQSバッファ(D)はトラフィックを平滑化できますが、同時実行を増やしません。",
      "difficulty": "medium"
    },
    {
      "id": "q17",
      "domain": 4,
      "question": "開発者が分散マイクロサービスアプリケーションをデバッグする必要があります。API Gatewayから複数のLambda関数を経由してDynamoDBまでのリクエストの完全なパスを追跡する必要があります。どのツールを使用すべきですか？",
      "options": {
        "A": "CloudWatch Logs",
        "B": "AWS X-Ray",
        "C": "CloudWatch Metrics",
        "D": "VPC Flow Logs"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "AWS X-Rayはエンドツーエンドの分散トレースを提供します：\n- AWSサービス間の呼び出しを自動追跡\n- サービスマップと依存関係を視覚化\n- 各サービスのレイテンシーとエラーを表示\n- カスタムサブセグメントとアノテーションをサポート\n\nCloudWatch Logs(A)はログのみを提供します。CloudWatch Metrics(C)は集約メトリクスを提供します。VPC Flow Logs(D)はネットワークトラフィック用です。",
      "difficulty": "medium"
    },
    {
      "id": "q18",
      "domain": 4,
      "question": "開発者がDynamoDB Scan操作が大量の読み取り容量を消費し、タイムアウトを引き起こしていることを発見しました。どのように最適化すべきですか？",
      "options": {
        "A": "ScanをQuery操作に置き換える",
        "B": "テーブルの読み取り容量ユニットを増やす",
        "C": "並列Scanを使用する",
        "D": "ScanのProjectionExpressionを削減する"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "Query操作はScanより効率的です：\n- Queryはパーティションキーに一致するアイテムのみを読み取る\n- Scanはテーブル全体を読み取る\n- アクセスパターンを再設計してQueryを使用\n- グローバルセカンダリインデックス（GSI）で異なるクエリをサポート\n\nRCUの増加(B)は効率の問題を解決しません。並列Scan(C)は依然としてテーブル全体を読み取ります。プロジェクション削減(D)は返されるデータ量のみを削減します。",
      "difficulty": "medium"
    },
    {
      "id": "q19",
      "domain": 4,
      "question": "開発者がLambda関数で「Rate Exceeded」エラーを受け取りました。これはどのような問題を示していますか？",
      "options": {
        "A": "関数の実行時間が長すぎる",
        "B": "関数メモリが不足している",
        "C": "関数の同時実行が制限に達している",
        "D": "関数コードサイズが超過している"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "Rate Exceededエラーは Lambda同時実行制限を示します：\n- アカウントレベルの同時実行制限（デフォルト1000）\n- 関数レベルの予約済み同時実行制限\n- 制限を増やすか同時実行需要を減らす必要がある\n- アカウント制限の引き上げをリクエスト可能\n\n実行時間(A)はタイムアウトエラーを引き起こします。メモリ不足(B)はOOMエラーを引き起こします。コードサイズ(D)はデプロイ時にチェックされます。",
      "difficulty": "medium"
    },
    {
      "id": "q20",
      "domain": 4,
      "question": "開発者がLambda関数のログが90日後にCloudWatch Logsで自動的に削除されることを確認する必要があります。どのように設定すべきですか？",
      "options": {
        "A": "Lambda関数設定でログ保持を設定する",
        "B": "CloudWatch Logsロググループで保持ポリシーを設定する",
        "C": "CloudWatch Eventsを使用して定期的にログを削除する",
        "D": "SAMテンプレートでログTTLを設定する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CloudWatch Logsロググループには保持ポリシー設定があります：\n- 1日から10年までの保持期間を設定可能\n- 保持期間を超えたログは自動的に削除\n- ロググループ設定で構成\n- デフォルトは無期限\n\nLambda関数設定(A)はログ保持を制御しません。Events(C)はイベントルーティングサービスです。SAMには直接的なログTTL設定がありません(D)。",
      "difficulty": "medium"
    },
    {
      "id": "q21",
      "domain": 1,
      "question": "開発者がAPI GatewayでWebSocket APIを作成しています。クライアント接続時に認証を実行する必要があります。どのルートで認可を設定すべきですか？",
      "options": {
        "A": "$connectルート",
        "B": "$disconnectルート",
        "C": "$defaultルート",
        "D": "すべてのカスタムルート"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "$connectルートはWebSocket接続確立時に実行されます：\n- 認証を実行する理想的な場所\n- 認可が失敗した場合、接続は拒否される\n- Lambdaオーソライザーを設定可能\n- 後続のメッセージは確立された接続を使用\n\n$disconnect(B)は切断時に実行されます。$default(C)は一致しないルートを処理します。カスタムルート(D)は特定のメッセージタイプ用です。",
      "difficulty": "medium"
    },
    {
      "id": "q22",
      "domain": 1,
      "question": "開発者がStep Functions Expressワークフローを使用して短時間の同期タスクを処理しています。標準ワークフローと比較して、Expressワークフローにはどのような制限がありますか？",
      "options": {
        "A": "最大実行時間5分",
        "B": "Lambda統合をサポートしない",
        "C": "Parallel状態をサポートしない",
        "D": "最大実行時間15分"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "Expressワークフローは短時間・高スループットシナリオ向けに設計されています：\n- 最大実行時間5分\n- 実行回数と持続時間に基づいて課金\n- 同期および非同期実行をサポート\n- 高スループット、毎秒100,000回以上\n\n標準ワークフローは最大1年実行可能です。Expressはすべての状態タイプをサポートします(B,C)。",
      "difficulty": "medium"
    },
    {
      "id": "q23",
      "domain": 1,
      "question": "開発者がDynamoDBテーブルで楽観的ロックを実装して並行更新の競合を防止する必要があります。どの機能を使用すべきですか？",
      "options": {
        "A": "条件式とバージョン番号属性",
        "B": "DynamoDBトランザクション",
        "C": "強力な整合性のある読み取り",
        "D": "DynamoDB Streams"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "楽観的ロックは条件式を使用して実装します：\n- アイテムにバージョン番号属性を維持\n- 更新時にConditionExpressionでバージョンをチェック\n- バージョンが一致しない場合、更新は失敗\n- アプリケーションは最新バージョンを読み取ってリトライ\n\nトランザクション(B)は原子的なマルチアイテム操作用です。強力な整合性(C)は読み取りオプションです。DynamoDB Streams(D)は変更データキャプチャです。",
      "difficulty": "medium"
    },
    {
      "id": "q24",
      "domain": 1,
      "question": "開発者がLambda関数を使用してS3イベントを処理しています。関数は同じオブジェクトの複数のイベント（同じファイルの複数回更新など）を処理する必要があります。処理順序を確保するにはどうすべきですか？",
      "options": {
        "A": "S3イベント通知は順序を保証する",
        "B": "SQS FIFOキューをイベントターゲットとして使用する",
        "C": "Lambda同時実行制限を増やす",
        "D": "DynamoDBロック機構を使用する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "SQS FIFOキューはメッセージの順序を保証します：\n- S3オブジェクトキーをメッセージグループIDとして使用\n- 同じオブジェクトのイベントは順序どおりに処理\n- LambdaはFIFOキューをイベントソースとして使用\n- 正確に1回の処理セマンティクス\n\nS3イベントは順序を保証しません(A)。同時実行(C)は順序と無関係です。DynamoDBロック(D)は複雑で順序を保証しません。",
      "difficulty": "medium"
    },
    {
      "id": "q25",
      "domain": 1,
      "question": "開発者がAmazon ECSを使用してコンテナ化されたアプリケーションを実行しています。タスク定義に公開せずに機密設定をコンテナに注入する必要があります。どの方法を使用すべきですか？",
      "options": {
        "A": "タスク定義で環境変数を使用する",
        "B": "Secrets Manager統合を使用してシークレットを注入する",
        "C": "コンテナイメージに設定を埋め込む",
        "D": "ECS実行ロールを使用して認証情報を渡す"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "ECSはSecrets ManagerとParameter Storeと統合されています：\n- タスク定義でシークレットARNを参照\n- 実行時に自動的に環境変数として注入\n- シークレット値はタスク定義に公開されない\n- 自動ローテーションをサポート\n\n平文環境変数(A)は安全ではありません。イメージ埋め込み(C)は更新が困難です。実行ロール(D)はECSエージェント権限用です。",
      "difficulty": "medium"
    },
    {
      "id": "q26",
      "domain": 2,
      "question": "開発者がAPI Gateway REST APIにカスタム認可ロジックを実装する必要があります。認可はカスタムトークンを検証してIAMポリシーを返す必要があります。どのタイプのオーソライザーを使用すべきですか？",
      "options": {
        "A": "Cognitoユーザープールオーソライザー",
        "B": "Lambda TOKENオーソライザー",
        "C": "Lambda REQUESTオーソライザー",
        "D": "IAM認可"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Lambda TOKENオーソライザーはトークンベースの認可を処理します：\n- Authorizationヘッダーまたはカスタムヘッダーからトークンを取得\n- Lambda関数がトークンを検証してIAMポリシーを返す\n- ポリシーキャッシュをサポートしてLambda呼び出しを削減\n- カスタムトークン検証に適切\n\nCognito(A)はJWTトークン用です。REQUEST(C)は完全なリクエストコンテキストにアクセスできます。IAM(D)はAWS署名用です。",
      "difficulty": "medium"
    },
    {
      "id": "q27",
      "domain": 2,
      "question": "開発者がLambda関数でAWS SDKを使用して複数のAWSサービスにアクセスする必要があります。関数のIAMロールをどのように設定すべきですか？",
      "options": {
        "A": "AWSマネージドポリシーAdministratorAccessを使用する",
        "B": "各サービスに個別のロールを作成して切り替える",
        "C": "必要な操作とリソースのみを含むカスタムポリシーを作成する",
        "D": "サービスリンクロールを使用する"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "最小権限の原則はカスタムの正確なポリシーを要求します：\n- 関数が実際に必要な操作のみを付与\n- リソースARNを使用して特定のリソースに制限\n- ワイルドカードの使用を避ける\n- 定期的に権限を確認して絞り込む\n\n管理者アクセス(A)は権限が広すぎます。複数ロール切り替え(B)は複雑で不要です。サービスリンクロール(D)は特定のAWSサービス用です。",
      "difficulty": "medium"
    },
    {
      "id": "q28",
      "domain": 2,
      "question": "開発者がS3バケット内のすべてのオブジェクトがカスタマー管理のKMSキーで暗号化されることを確認する必要があります。どのように強制すべきですか？",
      "options": {
        "A": "バケットのデフォルト暗号化を設定する",
        "B": "バケットポリシーを使用して非暗号化アップロードを拒否する",
        "C": "S3オブジェクトロックを有効にする",
        "D": "S3バージョニングを設定する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "バケットポリシーは特定の暗号化の使用を強制できます：\n- s3:x-amz-server-side-encryption条件キーを使用\n- 暗号化要件を満たさないPutObjectリクエストを拒否\n- 特定のKMSキーの使用を必須にできる\n- 暗号化されていないオブジェクトの誤ったアップロードを防止\n\nデフォルト暗号化(A)は上書きできます。オブジェクトロック(C)はWORM用です。バージョニング(D)は暗号化と無関係です。",
      "difficulty": "medium"
    },
    {
      "id": "q29",
      "domain": 2,
      "question": "開発者がAWS KMSを使用してデータを暗号化しています。アプリケーションは4KBを超えるデータを暗号化する必要があります。どの方法を使用すべきですか？",
      "options": {
        "A": "KMS Encrypt APIを直接使用する",
        "B": "エンベロープ暗号化を使用する",
        "C": "データを4KBチャンクに分割する",
        "D": "S3サーバー側暗号化を使用する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "エンベロープ暗号化は大きなデータの暗号化に使用します：\n- KMSを使用してデータキーを生成（GenerateDataKey）\n- データキーを使用してローカルでデータを暗号化\n- 暗号化されたデータキーと暗号化データを保存\n- KMS Encrypt APIは4KBに制限\n\n直接API(A)にはサイズ制限があります。分割(C)は複雑で実用的ではありません。S3暗号化(D)は特定サービスの機能です。",
      "difficulty": "medium"
    },
    {
      "id": "q30",
      "domain": 2,
      "question": "開発者がCognitoユーザープールで多要素認証（MFA）を実装する必要があります。何を設定すべきですか？",
      "options": {
        "A": "SMS MFAのみを使用する",
        "B": "TOTP MFAのみを使用する",
        "C": "オプションまたは必須のMFAを設定し、SMSとTOTPをサポートする",
        "D": "カスタムLambdaトリガーを使用してMFAを実装する"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "Cognitoユーザープールは柔軟なMFA設定をサポートします：\n- オフ、オプション、または必須に設定可能\n- SMSとソフトウェアトークン（TOTP）の両方の方式をサポート\n- ユーザーは優先方式を選択可能\n- ユーザープール設定で構成\n\n単一方式(A,B)は柔軟性を制限します。カスタムLambda(D)は複雑さを増し、不要です。",
      "difficulty": "medium"
    },
    {
      "id": "q31",
      "domain": 3,
      "question": "開発者がAWS CDKを使用してインフラストラクチャを定義しています。CDKコードは合成前にプロパティ値を検証する必要があります。どの方法を使用すべきですか？",
      "options": {
        "A": "CloudFormation検証ルールを使用する",
        "B": "CDKコードにプログラム検証ロジックを追加する",
        "C": "CDK Aspectsを使用して検証する",
        "D": "ランタイムエラー検出に依存する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CDKのプログラム特性により合成前の検証が可能です：\n- 条件文を使用してプロパティ値を検証\n- 例外をスローして無効な設定を阻止\n- コンパイル時（TypeScript）または実行時にチェック\n- CloudFormationデプロイエラーより早く問題を発見\n\nCDK Aspects(C)はコンストラクト間の変更適用用です。CloudFormation検証(A)はデプロイ時のチェックです。",
      "difficulty": "medium"
    },
    {
      "id": "q32",
      "domain": 3,
      "question": "開発チームがAWS CodePipelineを使用して継続的デプロイを行っています。Lambda関数をデプロイした後、自動的に統合テストを実行する必要があります。どのように設定すべきですか？",
      "options": {
        "A": "CodeDeployデプロイグループでテストを設定する",
        "B": "デプロイ後にCodeBuildテストステージを追加して実行する",
        "C": "デプロイ後にテストをトリガーするLambda宛先を使用する",
        "D": "sam deployコマンドにテストを含める"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "CodePipelineステージは複数のアクションを順次実行できます：\n- デプロイステージの後にテストステージを追加\n- CodeBuildプロジェクトを使用して統合テストを実行\n- テスト失敗時にパイプラインは停止\n- アラーム通知を設定可能\n\nCodeDeploy(A)は主にEC2デプロイ検証用です。Lambda宛先(C)は追加のオーケストレーションが必要です。sam deploy(D)にはテスト機能が含まれていません。",
      "difficulty": "medium"
    },
    {
      "id": "q33",
      "domain": 3,
      "question": "開発者がAWS SAMを使用してLambda関数をローカルでデバッグする必要があります。関数はローカル開発にDynamoDB Localを使用しています。ローカルAPIを起動してDockerネットワークに接続するにはどのコマンドを使用すべきですか？",
      "options": {
        "A": "sam local start-api --docker-network host",
        "B": "sam local start-api --docker-network <network-name>",
        "C": "sam local invoke --docker-network host",
        "D": "sam build --use-container"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "SAM CLIはDockerネットワーク設定をサポートします：\n- --docker-networkパラメータでDockerネットワークを指定\n- Lambdaコンテナは同じネットワーク内の他のコンテナにアクセス可能\n- DynamoDB Local、LocalStackなど\n- ローカルエンドツーエンドテストに便利\n\nホストネットワークモード(A,C)はポート競合を引き起こす可能性があります。sam build(D)はビルドコマンドです。",
      "difficulty": "medium"
    },
    {
      "id": "q34",
      "domain": 3,
      "question": "開発者がCloudFormationを使用してLambda関数を管理しています。コードが更新されるたびに自動的に新しいバージョンを作成する必要があります。どのように設定すべきですか？",
      "options": {
        "A": "手動でPublishVersion APIを呼び出す",
        "B": "AWS::Lambda::Versionリソースを使用してAutoPublishCodeSha256を設定する",
        "C": "SAMのAutoPublishAlias属性を使用する",
        "D": "Lambdaのバージョン管理ポリシーを設定する"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "SAMはLambdaバージョン管理を簡素化します：\n- AutoPublishAliasは新しいバージョンを自動的に作成\n- コード変更時にエイリアスを新しいバージョンに更新\n- DeploymentPreferenceと組み合わせて段階的デプロイを実現\n- バージョンリソースの手動管理不要\n\nCloudFormationバージョンリソース(B)は複雑な設定が必要です。手動API(A)は自動化されていません。",
      "difficulty": "medium"
    },
    {
      "id": "q35",
      "domain": 3,
      "question": "開発チームがデプロイ前にCloudFormationテンプレートの構文とベストプラクティスを検証する必要があります。どのツールを使用すべきですか？",
      "options": {
        "A": "aws cloudformation validate-template",
        "B": "cfn-lint",
        "C": "aws cloudformation create-change-set",
        "D": "sam validate"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "cfn-lintは包括的なテンプレート検証を提供します：\n- 構文エラーをチェック\n- リソースプロパティを検証\n- ベストプラクティスをチェック\n- CI/CDパイプラインに統合可能\n\nvalidate-template(A)は基本的な構文のみをチェックします。create-change-set(C)はデプロイが必要です。sam validate(D)はSAMテンプレート専用です。",
      "difficulty": "medium"
    },
    {
      "id": "q36",
      "domain": 4,
      "question": "開発者がLambda関数が大きなリクエストを処理する際にメモリ不足になることを発見しました。CloudWatchログには「Process exited before completing request」と表示されます。どのように解決すべきですか？",
      "options": {
        "A": "関数のタイムアウト設定を増やす",
        "B": "関数のメモリ設定を増やす",
        "C": "関数コードを最適化してメモリ使用量を削減する",
        "D": "BとCの両方が正しい"
      },
      "answer": "D",
      "answerType": "single",
      "explanation": "メモリ不足の問題は複数の方法で解決できます：\n- 割り当てられたメモリを増やす\n- コードを最適化してメモリ占有を削減\n- 大きなデータにはストリーム処理を使用\n- メモリ内にデータセット全体を読み込むことを避ける\n\nタイムアウト設定(A)はメモリ制限に影響しません。メモリ増加(B)はCPUクォータも増加させます。コード最適化(C)は長期的な解決策です。",
      "difficulty": "medium"
    },
    {
      "id": "q37",
      "domain": 4,
      "question": "開発者がLambda関数の同時実行数を監視し、制限に近づいたときにアラートを受け取る必要があります。どのCloudWatchメトリクスを監視すべきですか？",
      "options": {
        "A": "Invocations",
        "B": "ConcurrentExecutions",
        "C": "Duration",
        "D": "Throttles"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "ConcurrentExecutionsは現在の同時実行数を示します：\n- アカウントレベルと関数レベルで利用可能\n- 制限に近づいたときに通知するアラームを設定可能\n- 同時実行容量を積極的に管理するのに役立つ\n- アカウント同時実行制限と比較\n\nInvocations(A)は呼び出しの合計数です。Duration(C)は実行時間です。Throttles(D)はすでにスロットリングされたリクエストを示します。",
      "difficulty": "medium"
    },
    {
      "id": "q38",
      "domain": 4,
      "question": "開発者がAPI Gateway REST APIのリクエストパターンを分析する必要があります。HTTPメソッドとリソースパスでグループ化されたリクエスト数を確認する必要があります。何を使用すべきですか？",
      "options": {
        "A": "CloudWatch Logs InsightsでAPI Gatewayログをクエリする",
        "B": "X-Rayサービスマップ",
        "C": "API Gatewayコンソールの使用量プラン",
        "D": "CloudTrailログ"
      },
      "answer": "A",
      "answerType": "single",
      "explanation": "CloudWatch Logs InsightsはAPI Gatewayアクセスログを分析できます：\n- API Gatewayアクセスログを有効化\n- Logs Insightsを使用してクエリと集計\n- メソッド、パス、ステータスコードでグループ化\n- 視覚化レポートを生成\n\nX-Ray(B)はレイテンシー追跡用です。使用量プラン(C)はクォータ管理用です。CloudTrail(D)はAPI呼び出しを記録し、リクエスト詳細ではありません。",
      "difficulty": "medium"
    },
    {
      "id": "q39",
      "domain": 4,
      "question": "開発者がSQSメッセージ処理Lambda関数の複数回失敗アラートを受け取りました。メッセージは数回処理された後、デッドレターキューに移動されました。失敗の原因を調査するにはどうすべきですか？",
      "options": {
        "A": "Lambda関数のCloudWatchログを確認する",
        "B": "デッドレターキュー内のメッセージ内容と属性を分析する",
        "C": "X-Rayトレースを確認する",
        "D": "上記すべてを使用すべき"
      },
      "answer": "D",
      "answerType": "single",
      "explanation": "包括的な調査には複数のツールが必要です：\n- CloudWatchログ：エラー詳細とスタックトレースを確認\n- DLQメッセージ：失敗を引き起こした元のデータを確認\n- X-Ray：リクエストフローと依存関係呼び出しを分析\n- 組み合わせて使用することで問題の全体像を把握\n\n単一のツールでは完全な情報を提供できない可能性があります。",
      "difficulty": "medium"
    },
    {
      "id": "q40",
      "domain": 4,
      "question": "開発者がLambda関数の最初の呼び出しのレイテンシーが高いが、後続の呼び出しは正常であることに気づきました。これはどのような問題ですか？どのように解決すべきですか？",
      "options": {
        "A": "ネットワークレイテンシーの問題、VPCエンドポイントを使用する",
        "B": "コールドスタートの問題、プロビジョニング済み同時実行を使用する",
        "C": "DynamoDBスロットリング、容量を増やす",
        "D": "API Gatewayキャッシュの問題"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "最初の呼び出しのレイテンシーが高いのはコールドスタートの典型的な特徴です：\n- Lambdaは実行環境を初期化する必要がある\n- コードの読み込み、ランタイムの初期化を含む\n- 後続の呼び出しはウォームアップ済みの環境を再利用\n- プロビジョニング済み同時実行は環境をウォーム状態に保つ\n\n他のオプションは最初の呼び出しだけでなく、すべての呼び出しに影響します。",
      "difficulty": "medium"
    }
  ]
}

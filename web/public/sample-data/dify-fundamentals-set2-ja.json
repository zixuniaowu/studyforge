{
  "exam": {
    "id": "dify-fundamentals-set2-ja",
    "name": "Dify 基礎認定 模擬試験 #2",
    "code": "DIFY-FUND",
    "provider": "Dify",
    "language": "ja",
    "description": "Dify AIアプリケーション開発プラットフォーム基礎認定 - 第2セット",
    "totalQuestions": 50,
    "passingScore": 70,
    "examTime": 60,
    "domains": [
      { "id": 1, "name": "Dify Platform Basics", "weight": 25 },
      { "id": 2, "name": "Prompt Engineering", "weight": 25 },
      { "id": 3, "name": "Application Types", "weight": 25 },
      { "id": 4, "name": "Basic Configuration", "weight": 25 }
    ],
    "tags": ["Dify", "LLMOps", "AI", "認定試験"]
  },
  "questions": [
    {
      "id": "q1",
      "domain": 1,
      "question": "Dify のコアポジショニングは何ですか？",
      "options": {
        "A": "純粋なチャットボット",
        "B": "オープンソースのLLMアプリケーション開発プラットフォーム、AIアプリを迅速に構築できる",
        "C": "クラウドストレージサービス",
        "D": "画像処理ソフトウェア"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Dify はオープンソースのLLMアプリケーション開発プラットフォームです：\n- ビジュアルアプリケーション編集インターフェースを提供\n- 複数のアプリケーションタイプをサポート\n- 組み込みRAGエンジン\n- APIサービス機能を提供\n\n目標は、開発者が本番レベルのAIアプリケーションを迅速に構築できるようにすることです。",
      "difficulty": "easy"
    },
    {
      "id": "q2",
      "domain": 1,
      "question": "Dify における「アプリケーションテンプレート」とは何ですか？",
      "options": {
        "A": "モデルの事前学習済み重み",
        "B": "事前設定済みのアプリケーション、直接使用または変更の出発点として使用可能",
        "C": "データベーステーブル構造",
        "D": "ユーザーインターフェーステーマ"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "アプリケーションテンプレートは事前設定されたアプリケーションです：\n- 完全なPrompt設定を含む\n- ツールとナレッジベースが設定済み\n- 直接デプロイして使用可能\n- カスタム変更のベースとしても使用可能\n\nテンプレートにより、ゼロから始めることなくプロジェクトを迅速に開始できます。",
      "difficulty": "easy"
    },
    {
      "id": "q3",
      "domain": 1,
      "question": "Dify の Docker Compose デプロイに必要な最小メモリはどれくらいですか？",
      "options": {
        "A": "512MB",
        "B": "1GB",
        "C": "4GB",
        "D": "16GB"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "Dify Docker Composeデプロイの最小要件：\n- メモリ：4GB RAM\n- CPU：2コア\n- ストレージ：ベクターデータベースとファイルを保存するのに十分な容量\n\n本番環境ではパフォーマンスを確保するためにより高い構成を推奨します。",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "domain": 1,
      "question": "Dify がサポートするユーザー認証形式はどれですか？（2つ選択）",
      "options": {
        "A": "メールパスワードログイン",
        "B": "GitHub OAuth",
        "C": "指紋認証",
        "D": "虹彩スキャン"
      },
      "answer": ["A", "B"],
      "answerType": "multiple",
      "explanation": "Difyは複数の認証方式をサポートしています：\n- メールパスワード：基本的な認証方式\n- OAuth：GitHub、Googleなどのサードパーティログインをサポート\n- SSO：エンタープライズ版はシングルサインオンをサポート\n\n指紋や虹彩などの生体認証は現在サポートされていません。",
      "difficulty": "easy"
    },
    {
      "id": "q5",
      "domain": 1,
      "question": "Dify で複数のプロジェクトを管理するにはどうすればよいですか？",
      "options": {
        "A": "複数のプロジェクトを管理することはできない",
        "B": "複数のWorkspace（ワークスペース）を作成して異なるプロジェクトを分離",
        "C": "コードでのみ設定可能",
        "D": "複数のDifyインスタンスをデプロイする必要がある"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "DifyはWorkspaceを通じて複数のプロジェクトを管理します：\n- 各Workspaceは独立したリソース空間\n- 独立したアプリケーション、ナレッジベース、モデル設定を含む\n- 独立したチームメンバー管理をサポート\n- 複数のインスタンスをデプロイせずにプロジェクトを分離可能",
      "difficulty": "easy"
    },
    {
      "id": "q6",
      "domain": 2,
      "question": "以下のうち、Promptエンジニアリングのベストプラクティスはどれですか？",
      "options": {
        "A": "曖昧な説明を使用してモデルに自由に発揮させる",
        "B": "明確なタスク説明、出力形式要件、関連する例を提供する",
        "C": "できるだけ短いプロンプトを使用する",
        "D": "句読点の使用を避ける"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Promptエンジニアリングのベストプラクティス：\n- 明確なタスク説明：何が必要かを明確に説明\n- 出力形式の指定：JSON、リスト、段落など\n- 例を提供：Few-shot learning\n- 制約条件の設定：境界と制限\n\n曖昧な説明は予期しない出力につながります。",
      "difficulty": "easy"
    },
    {
      "id": "q7",
      "domain": 2,
      "question": "Context Window（コンテキストウィンドウ）とは何ですか？",
      "options": {
        "A": "アプリケーションのビジュアルインターフェース",
        "B": "モデルが一度に処理できる最大トークン数",
        "C": "ナレッジベースのストレージ容量",
        "D": "APIの同時接続制限"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Context Windowはモデルのコンテキストウィンドウサイズです：\n- 一度の会話で処理できる最大トークン数を決定\n- 入力（Prompt + 履歴 + ナレッジベースコンテンツ）と出力を含む\n- モデルによってウィンドウサイズが異なる\n- GPT-4 Turboは128Kトークンをサポート\n\nウィンドウサイズを超えるコンテンツは切り捨てられます。",
      "difficulty": "medium"
    },
    {
      "id": "q8",
      "domain": 2,
      "question": "Promptで {{#context#}} 変数を使用する目的は何ですか？",
      "options": {
        "A": "ユーザー入力を挿入",
        "B": "ナレッジベースから検索された関連コンテンツを挿入",
        "C": "システム時刻を挿入",
        "D": "会話履歴を挿入"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "{{#context#}} 変数はナレッジベースコンテンツを注入するために使用されます：\n- ユーザーが質問すると、システムはナレッジベースを検索\n- 検索された関連フラグメントが {{#context#}} を置換\n- モデルはこれらのコンテキストに基づいて回答を生成\n- これがRAGシステムのコアメカニズム",
      "difficulty": "medium"
    },
    {
      "id": "q9",
      "domain": 2,
      "question": "Stop Sequences（停止シーケンス）の役割は何ですか？",
      "options": {
        "A": "モデルの応答速度を向上させる",
        "B": "モデルが特定の文字列を生成したときに出力を停止する",
        "C": "ユーザー入力の長さを制限する",
        "D": "APIサービスを停止する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Stop Sequencesはモデル出力の終了点を制御するために使用されます：\n- モデルが指定された文字列を生成すると停止\n- フォーマット出力制御によく使用される\n- 例：\"\\n\\n\" を設定すると、2つの改行を生成後に停止\n- 複数の停止シーケンスを設定可能",
      "difficulty": "medium"
    },
    {
      "id": "q10",
      "domain": 2,
      "question": "モデルのハルシネーション（Hallucination）を効果的に防ぐPromptの設計方法は？",
      "options": {
        "A": "モデルに自由にコンテンツを生成させる",
        "B": "提供されたコンテキストのみに基づいて回答し、不確かな場合は「わかりません」と言うよう明確に指示",
        "C": "Temperature値を上げる",
        "D": "すべての例を削除する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "モデルのハルシネーションを減らす方法：\n- 提供されたコンテキストのみに基づいて回答することを明確に要求\n- モデルが「わかりません」や「情報不足」と言うことを許可\n- 低いTemperature値を使用（より決定論的な出力）\n- 十分な関連コンテキストを提供\n- 出典の引用を要求",
      "difficulty": "medium"
    },
    {
      "id": "q11",
      "domain": 2,
      "question": "Negative Prompting とは何ですか？",
      "options": {
        "A": "ユーザーの入力を批判する",
        "B": "プロンプトで何をしてはいけないかを明確に述べる",
        "C": "パラメータとして負の数を使用する",
        "D": "会話履歴を削除する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Negative Promptingはプロンプト技術の一つです：\n- モデルに何をしてはいけないかを明確に伝える\n- 例：「情報を捏造しないでください」「技術用語を使わないでください」\n- 禁止される行動の境界を設定\n- 正の指示と組み合わせるとより効果的",
      "difficulty": "medium"
    },
    {
      "id": "q12",
      "domain": 2,
      "question": "Frequency Penalty と Presence Penalty の違いは何ですか？",
      "options": {
        "A": "両者は完全に同じ",
        "B": "Frequency Penaltyはトークンの出現頻度に基づき、Presence Penaltyは出現したかどうかに基づく",
        "C": "一方は入力用、もう一方は出力用",
        "D": "一方は英語用、もう一方は中国語用"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "両者とも繰り返しを制御するために使用されますが、メカニズムが異なります：\n\nFrequency Penalty：\n- トークンがすでに出現した回数に基づく\n- 出現回数が多いほどペナルティが重くなる\n\nPresence Penalty：\n- トークンが出現したかどうかのみを見る\n- 出現回数は考慮しない\n\n通常、どちらか一方を調整すれば十分です。",
      "difficulty": "hard"
    },
    {
      "id": "q13",
      "domain": 3,
      "question": "Text Generator アプリケーションが最も適しているシナリオはどれですか？",
      "options": {
        "A": "マルチターンカスタマーサービス会話",
        "B": "一回限りのテキスト翻訳または要約タスク",
        "C": "ツール呼び出しが必要な複雑なタスク",
        "D": "複数ステップのデータ処理フロー"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Text Generatorは単一処理タスクに適しています：\n- 翻訳：テキストをある言語から別の言語に翻訳\n- 要約：記事やドキュメントの要約を生成\n- フォーマット変換：JSONからXMLなど\n- テキスト分類：感情分析、トピック分類\n\n会話履歴や複雑なフローが必要なシナリオには適していません。",
      "difficulty": "easy"
    },
    {
      "id": "q14",
      "domain": 3,
      "question": "Agent アプリケーションにおける「反復回数制限」パラメータの役割は何ですか？",
      "options": {
        "A": "ユーザーがメッセージを送信する回数を制限",
        "B": "Agentの推論とツール呼び出しの最大ループ回数を制限",
        "C": "ナレッジベース検索回数を制限",
        "D": "API呼び出し頻度を制限"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "反復回数制限はAgentの実行深度を制御します：\n- Agentは複数回の推論とツール呼び出しが必要な場合がある\n- 制限により無限ループを防止\n- リソース消費を保護\n- デフォルトは通常5〜10回に設定\n\nタスクが完了していなくても制限に達すると、Agentは停止して現在の結果を返します。",
      "difficulty": "medium"
    },
    {
      "id": "q15",
      "domain": 3,
      "question": "Workflow の「開始ノード」（Start Node）の役割は何ですか？",
      "options": {
        "A": "ワークフローの実行を終了する",
        "B": "ワークフローの入力変数とトリガー条件を定義",
        "C": "外部APIを呼び出す",
        "D": "通知を送信する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "開始ノードはWorkflowのエントリーポイントです：\n- ワークフローに必要な入力変数を定義\n- 変数タイプを設定（テキスト、数値、ファイルなど）\n- デフォルト値を設定可能\n- すべての後続ノードでこれらの変数を使用可能\n\n各Workflowには必ず1つだけ開始ノードが必要です。",
      "difficulty": "easy"
    },
    {
      "id": "q16",
      "domain": 3,
      "question": "Workflow の「終了ノード」（End Node）の役割は何ですか？",
      "options": {
        "A": "ワークフローの実行を開始する",
        "B": "ワークフローの最終出力コンテンツを定義",
        "C": "特定のステップをループ実行",
        "D": "エラー通知を送信"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "終了ノードはWorkflowの出力を定義します：\n- 最終的にユーザーに返されるコンテンツを指定\n- 前のノードの出力を参照可能\n- テキスト、JSON、ファイルなど複数の形式をサポート\n- 1つのWorkflowに複数の終了ノードを持てる（異なる分岐用）",
      "difficulty": "easy"
    },
    {
      "id": "q17",
      "domain": 3,
      "question": "Agent と Chatbot の主な違いは何ですか？",
      "options": {
        "A": "Agentは会話をサポートしない",
        "B": "Agentは自律的にツールを呼び出してタスクを実行できる",
        "C": "Chatbotは「はい」か「いいえ」しか答えられない",
        "D": "両者に違いはない"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "AgentとChatbotの主な違い：\n\nAgent：\n- ツールを呼び出せる（検索、コード実行など）\n- 自律的な計画と意思決定\n- 複雑なマルチステップタスクを完了できる\n\nChatbot：\n- 主に会話とナレッジベースに基づく\n- 事前設定されたPromptに依存して回答\n- ツール呼び出し機能を持たない",
      "difficulty": "medium"
    },
    {
      "id": "q18",
      "domain": 3,
      "question": "どのような状況で Agent ではなく Workflow を選択すべきですか？",
      "options": {
        "A": "柔軟なツール選択と自律的な意思決定が必要な場合",
        "B": "固定的で予測可能な処理フローが必要な場合",
        "C": "シンプルなQ&Aが必要な場合",
        "D": "リアルタイム会話が必要な場合"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Workflowは固定フローシナリオに適しています：\n- フローステップが確定的で予測可能\n- 厳密な実行順序が必要\n- デバッグと監視が容易\n- バッチ処理タスクに適している\n\nAgentは柔軟な意思決定が必要なシナリオにより適していますが、実行パスは予測不可能です。",
      "difficulty": "medium"
    },
    {
      "id": "q19",
      "domain": 4,
      "question": "Dify ナレッジベースがサポートする最大単一ファイルサイズはどれくらいですか？",
      "options": {
        "A": "1MB",
        "B": "5MB",
        "C": "15MB",
        "D": "100MB"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "Difyナレッジベースのファイル制限：\n- 単一ファイル最大15MB\n- 複数ファイルのバッチアップロードをサポート\n- 異なる形式には特定の制限がある場合がある\n- エンタープライズ版はより高い制限がある場合がある\n\n大きすぎるファイルは分割してからアップロードすることを推奨します。",
      "difficulty": "medium"
    },
    {
      "id": "q20",
      "domain": 4,
      "question": "ナレッジベースのインデックスモードにおける「高品質モード」と「エコノミーモード」の違いは何ですか？",
      "options": {
        "A": "両者に違いはない",
        "B": "高品質モードはより良いEmbeddingモデルを使用、エコノミーモードはキーワードインデックスを使用",
        "C": "高品質モードの方が速い",
        "D": "エコノミーモードは中国語をサポートしない"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "2つのインデックスモードの違い：\n\n高品質モード：\n- ベクターEmbeddingを使用\n- セマンティック検索をサポート\n- より多くのトークンを消費\n- 検索効果が優れている\n\nエコノミーモード：\n- キーワード/転置インデックスを使用\n- Embeddingトークンを消費しない\n- シンプルなシナリオに適している\n- コストが低い",
      "difficulty": "medium"
    },
    {
      "id": "q21",
      "domain": 4,
      "question": "ドキュメントチャンキングにおける「Overlap」（オーバーラップ）パラメータの役割は何ですか？",
      "options": {
        "A": "チャンクを完全に独立させる",
        "B": "隣接するチャンクが一部のコンテンツを共有し、コンテキストの一貫性を維持",
        "C": "チャンクコンテンツを暗号化",
        "D": "チャンクサイズを圧縮"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Overlap（オーバーラップ）の役割：\n- 隣接するチャンクがテキストの一部を共有\n- チャンク間のコンテキストの一貫性を維持\n- 重要な情報が途切れることを防ぐ\n- 検索の完全性を向上\n\n例：チャンクサイズ500、オーバーラップ50で、各チャンクは前のチャンクの最後の50文字を含みます。",
      "difficulty": "medium"
    },
    {
      "id": "q22",
      "domain": 4,
      "question": "外部データをDifyナレッジベースに同期できる方法はどれですか？",
      "options": {
        "A": "手動でファイルをアップロードするしかない",
        "B": "Notion、Webスクレイピングなど複数のデータソース同期をサポート",
        "C": "APIでのみアップロード可能",
        "D": "外部データ同期はサポートされていない"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Difyは複数のデータソース同期をサポートしています：\n- Notion：Notionワークスペースに直接接続\n- Webスクレイピング：指定されたURLのコンテンツを取得\n- ファイルアップロード：PDF、Word、Markdownなど\n- API：プログラムでアップロード\n\nこれらの方法を柔軟に組み合わせて使用できます。",
      "difficulty": "easy"
    },
    {
      "id": "q23",
      "domain": 4,
      "question": "Dify でアプリケーションがストリーミング出力（Streaming）をサポートするようにするにはどうすればよいですか？",
      "options": {
        "A": "特別なハードウェアサポートが必要",
        "B": "API呼び出し時にresponse_modeをstreamingに設定",
        "C": "ストリーミング出力はサポートされていない",
        "D": "エンタープライズ版の購入が必要"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Dify APIはストリーミング出力をサポートしています：\n- リクエストパラメータでresponse_mode: \"streaming\"を設定\n- Server-Sent Events（SSE）を使用して受信\n- 生成プロセスをリアルタイムで表示可能\n- ユーザーエクスペリエンスを向上\n\nコミュニティ版とクラウド版の両方でストリーミング出力をサポートしています。",
      "difficulty": "medium"
    },
    {
      "id": "q24",
      "domain": 4,
      "question": "Dify の API キーに関するセキュリティ上の注意点は何ですか？（2つ選択）",
      "options": {
        "A": "フロントエンドコードで公開しても問題ない",
        "B": "バックエンドに保存し、漏洩を防ぐべき",
        "C": "IPホワイトリストを設定してアクセスを制限できる",
        "D": "セキュリティリスクはない"
      },
      "answer": ["B", "C"],
      "answerType": "multiple",
      "explanation": "APIキーのセキュリティベストプラクティス：\n- フロントエンドコードで絶対に公開しない\n- バックエンドサービスを通じてプロキシ呼び出し\n- IPホワイトリストを使用してアクセス元を制限\n- 定期的にキーをローテーション\n- 異常な呼び出しを監視",
      "difficulty": "medium"
    },
    {
      "id": "q25",
      "domain": 4,
      "question": "アプリケーションでユーザー識別を実装するにはどうすればよいですか？",
      "options": {
        "A": "Difyはユーザー識別をサポートしていない",
        "B": "API呼び出し時にuserパラメータを渡してユーザーを識別",
        "C": "Cookieでのみ可能",
        "D": "追加プラグインの購入が必要"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "ユーザー識別の方法：\n- API呼び出し時にuserパラメータを渡す\n- ユーザーID、メール、または他の一意の識別子を使用可能\n- 会話履歴の追跡に使用\n- ユーザー行動の分析に便利\n\nこれはパーソナライズされた体験を実現するための基盤です。",
      "difficulty": "easy"
    },
    {
      "id": "q26",
      "domain": 1,
      "question": "Dify のフロントエンドはどのような技術スタックで開発されていますか？",
      "options": {
        "A": "Vue.js",
        "B": "React + Next.js",
        "C": "Angular",
        "D": "jQuery"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Difyのフロントエンド技術スタック：\n- React：コアUIフレームワーク\n- Next.js：Reactフレームワーク\n- TypeScript：型安全性\n- Tailwind CSS：スタイリング\n\nバックエンドはPython Flaskを使用しています。",
      "difficulty": "medium"
    },
    {
      "id": "q27",
      "domain": 1,
      "question": "Dify は非同期タスクを処理するためにどのメッセージキューを使用していますか？",
      "options": {
        "A": "RabbitMQ",
        "B": "Kafka",
        "C": "Celery + Redis",
        "D": "メッセージキューを使用していない"
      },
      "answer": "C",
      "answerType": "single",
      "explanation": "DifyはCelery + Redisを使用しています：\n- Celery：Python非同期タスクフレームワーク\n- Redis：メッセージブローカーと結果バックエンドとして\n- ナレッジベースのインデックス作成、ファイル処理などの時間のかかるタスクを処理\n\nこの組み合わせはPythonプロジェクトの一般的な選択です。",
      "difficulty": "medium"
    },
    {
      "id": "q28",
      "domain": 1,
      "question": "セルフホストのDifyバージョンをアップグレードするにはどうすればよいですか？",
      "options": {
        "A": "再インストールが必要",
        "B": "最新のイメージをプルしてコンテナを再起動",
        "C": "アップグレードできない",
        "D": "公式のリモートサポートでのみ可能"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Difyのアップグレード手順：\n1. データベースと設定をバックアップ\n2. 最新のDockerイメージをプル\n3. 現在のコンテナを停止\n4. 新しいイメージで起動\n5. データベースマイグレーションを実行（必要に応じて）\n\n公式ドキュメントに詳細なアップグレードガイドがあります。",
      "difficulty": "easy"
    },
    {
      "id": "q29",
      "domain": 2,
      "question": "Self-Consistency Prompting とは何ですか？",
      "options": {
        "A": "モデルに自己批判させる",
        "B": "複数回回答を生成し、最も一貫性のある結果を選択",
        "C": "文法エラーをチェック",
        "D": "プロンプトを圧縮"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Self-Consistency Prompting：\n- 同じ質問に対して複数回回答を生成\n- 多数決または一貫性評価を使用\n- 最も一般的または一貫性のある回答を選択\n- 複雑な推論の精度を向上\n\n数学、論理など確定的な回答が必要なシナリオに適しています。",
      "difficulty": "hard"
    },
    {
      "id": "q30",
      "domain": 2,
      "question": "多言語Promptを設計する際のベストプラクティスは何ですか？",
      "options": {
        "A": "英語のみを使用する",
        "B": "ターゲット言語に合わせて例と指示を調整し、一貫性を維持",
        "C": "複数の言語を混在させる",
        "D": "機械翻訳を使用すれば十分"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "多言語Promptのベストプラクティス：\n- 例と指示にターゲット言語を使用\n- 用語の一貫性を維持\n- 文化的な違いを考慮\n- 異なる言語での効果をテスト\n\n単純な機械翻訳は効果の低下につながる可能性があります。",
      "difficulty": "medium"
    },
    {
      "id": "q31",
      "domain": 2,
      "question": "Prompt Chaining とは何ですか？",
      "options": {
        "A": "長いプロンプトを複数のセグメントに分割",
        "B": "複雑なタスクを複数のシンプルなステップに分解して順次実行",
        "C": "プロンプトを暗号化",
        "D": "プロンプトをコピー＆ペースト"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Prompt Chaining（プロンプトチェーン）：\n- 複雑なタスクを複数のステップに分解\n- 前のステップの出力が次のステップの入力になる\n- 各ステップに専用のPromptを使用\n- 複雑なタスクの成功率を向上\n\n例：まず情報を抽出 → 次に分析 → 最後にレポートを生成。",
      "difficulty": "medium"
    },
    {
      "id": "q32",
      "domain": 3,
      "question": "Agent アプリケーションにおける「ツールの説明」の役割は何ですか？",
      "options": {
        "A": "開発者が読むためだけのもの",
        "B": "Agentがいつ、どのようにそのツールを使用するかを理解するのを助ける",
        "C": "ユーザーインターフェースに表示される",
        "D": "ドキュメントの生成に使用"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "ツールの説明の役割：\n- ツールの機能をAgentに伝える\n- 使用に適したシナリオを説明\n- 入力パラメータの形式と意味を説明\n- Agentはこれに基づいて呼び出すかどうかを決定\n\n明確な説明はAgentが正しいツールを選択する確率を向上させます。",
      "difficulty": "medium"
    },
    {
      "id": "q33",
      "domain": 3,
      "question": "Workflow の「HTTPリクエスト」ノードで何ができますか？",
      "options": {
        "A": "GETリクエストのみ送信可能",
        "B": "外部APIを呼び出し、様々なHTTPメソッドをサポート",
        "C": "内部サービスへのアクセスのみ可能",
        "D": "ファイルのダウンロードのみ可能"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "HTTPリクエストノードの機能：\n- GET、POST、PUT、DELETEなどのメソッドをサポート\n- リクエストヘッダーとリクエストボディを設定可能\n- JSON、Formなどの形式をサポート\n- レスポンスデータを処理可能\n\n外部システムとの統合に適しています。",
      "difficulty": "easy"
    },
    {
      "id": "q34",
      "domain": 3,
      "question": "Chatflow でマルチターン会話のコンテキスト管理を実装するにはどうすればよいですか？",
      "options": {
        "A": "コードを手動で書く必要がある",
        "B": "システムが自動的に会話履歴を維持し、変数を通じて渡す",
        "C": "マルチターン会話はサポートされていない",
        "D": "外部データベースが必要"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Chatflowのコンテキスト管理：\n- システムが自動的に会話履歴を維持\n- 履歴メッセージ数の制限を設定可能\n- 会話変数を通じて重要な情報を保存\n- 手動でコードを書く必要はない\n\nこれによりマルチターン会話アプリケーションの開発が大幅に簡素化されます。",
      "difficulty": "medium"
    },
    {
      "id": "q35",
      "domain": 3,
      "question": "Workflow の「変数アグリゲーター」ノードの役割は何ですか？",
      "options": {
        "A": "変数を削除する",
        "B": "複数の並列分岐の出力を1つの変数に統合",
        "C": "変数を暗号化する",
        "D": "変数タイプを変換する"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "変数アグリゲーターの役割：\n- 複数の並列分岐の出力をマージ\n- 分散した結果を1つに統合\n- 後続ノードでの統一処理を容易にする\n- 並列処理後の集約によく使用\n\n例：複数のAPIを並列で呼び出した後、結果を統合。",
      "difficulty": "medium"
    },
    {
      "id": "q36",
      "domain": 4,
      "question": "Parent-Child チャンキングモードの利点は何ですか？",
      "options": {
        "A": "ストレージスペースを節約",
        "B": "検索時は小さなチャンクを使用し、返す際はより大きなコンテキストを含む",
        "C": "インデックス作成を高速化",
        "D": "画像をサポート"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Parent-Childチャンキングモード：\n- 大きなチャンク（Parent）と小さなチャンク（Child）を作成\n- 検索には小さなチャンクを使用（より正確）\n- 返す際は対応する大きなチャンクを含める（より完全なコンテキスト）\n- 検索精度とコンテキストの完全性を両立",
      "difficulty": "hard"
    },
    {
      "id": "q37",
      "domain": 4,
      "question": "N-to-1 リコールモードとは何ですか？",
      "options": {
        "A": "1つの結果のみを返す",
        "B": "まずN個の結果をリコールし、1つのコンテキストにマージしてLLMに渡す",
        "C": "N人のユーザーが1つのアプリケーションを共有",
        "D": "1つの質問に対してN個の回答を生成"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "N-to-1リコールモード：\n- ナレッジベースからN個の関連フラグメントを検索\n- これらのフラグメントを1つのコンテキストにマージ\n- 一度にLLMに渡して回答を生成\n- 複数のフラグメントからの情報を総合する必要があるシナリオに適している",
      "difficulty": "medium"
    },
    {
      "id": "q38",
      "domain": 4,
      "question": "APIを通じて新しい会話を作成するにはどうすればよいですか？",
      "options": {
        "A": "/conversations/new を呼び出す",
        "B": "conversation_idを渡さなければ、システムが自動的に新しい会話を作成",
        "C": "まず認証インターフェースを呼び出す必要がある",
        "D": "APIでは作成できない"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "新しい会話を作成する方法：\n- メッセージを送信する際にconversation_idを渡さない\n- システムが自動的に新しい会話を作成しIDを返す\n- 後続のメッセージではそのIDを使用して会話を継続\n- シンプルなAPI設計",
      "difficulty": "easy"
    },
    {
      "id": "q39",
      "domain": 1,
      "question": "Dify のログ保持ポリシーはどのように設定できますか？",
      "options": {
        "A": "設定できない",
        "B": "環境変数でログ保持日数を設定",
        "C": "7日間のみ保持可能",
        "D": "エンタープライズ版の購入が必要"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "ログ保持の設定：\n- 環境変数で設定\n- 保持日数を設定可能\n- 期限切れのログを自動クリーンアップ\n- ストレージコストと履歴追跡の必要性のバランスを取る\n\nコミュニティ版でもこの機能をサポートしています。",
      "difficulty": "medium"
    },
    {
      "id": "q40",
      "domain": 1,
      "question": "Dify のデータをバックアップするにはどうすればよいですか？（2つ選択）",
      "options": {
        "A": "PostgreSQLデータベースをバックアップ",
        "B": "ベクターデータベースをバックアップ",
        "C": "コードのバックアップのみが必要",
        "D": "バックアップは不要"
      },
      "answer": ["A", "B"],
      "answerType": "multiple",
      "explanation": "Difyのデータバックアップに必要なもの：\n- PostgreSQL：アプリケーション設定、ユーザー、会話履歴\n- ベクターデータベース：ナレッジベースのベクターインデックス\n- ファイルストレージ：アップロードされたドキュメントファイル\n\n定期的にバックアップし、復旧プロセスをテストすることを推奨します。",
      "difficulty": "medium"
    },
    {
      "id": "q41",
      "domain": 2,
      "question": "Promptにおける Delimiter（区切り文字）の役割は何ですか？",
      "options": {
        "A": "フォーマットを美化",
        "B": "指示とコンテンツなど、異なる部分を明確に区別",
        "C": "テキストを圧縮",
        "D": "コンテンツを暗号化"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Delimiter（区切り文字）の役割：\n- Promptの異なる部分を明確に区別\n- よく使われるもの：\"\"\"、###、---、<>など\n- インジェクション攻撃を防止（ユーザー入力が指示に混入）\n- Promptの構造化度を向上\n\n例：以下の内容を翻訳してください：\\n---\\n{{content}}\\n---",
      "difficulty": "medium"
    },
    {
      "id": "q42",
      "domain": 2,
      "question": "構造化されたJSON出力を得るためのPrompt設計方法は？",
      "options": {
        "A": "特別な設計は不要",
        "B": "JSON形式を明確に要求し、サンプル構造を提供し、適切なTemperatureを設定",
        "C": "JSONモデルのみを使用",
        "D": "特別なAPIを使用"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "JSON出力を得るためのヒント：\n- JSON形式が必要であることを明確に述べる\n- 期待されるJSON構造のサンプルを提供\n- 低いTemperature（0-0.3）を使用\n- モデルにJSON有効性の検証を要求可能\n- 一部のモデルはJSONモードをサポート",
      "difficulty": "medium"
    },
    {
      "id": "q43",
      "domain": 3,
      "question": "Agent の「思考プロセス可視化」オプションの役割は何ですか？",
      "options": {
        "A": "すべての出力を非表示",
        "B": "Agentの推論と意思決定プロセスをユーザーに表示",
        "C": "応答速度を向上",
        "D": "トークン消費を削減"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "思考プロセス可視化の役割：\n- Agentの推論ステップを表示\n- ツール選択の理由を表示\n- 透明性と説明可能性を向上\n- デバッグと最適化を容易にする\n\n本番環境では必要に応じてオフにしてインターフェースをシンプルにできます。",
      "difficulty": "easy"
    },
    {
      "id": "q44",
      "domain": 3,
      "question": "Workflow の「ループ」ノードはどのタイプのループをサポートしていますか？",
      "options": {
        "A": "固定回数ループのみサポート",
        "B": "配列/リスト要素の反復をサポート",
        "C": "ループはサポートされていない",
        "D": "無限ループのみサポート"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Workflowのループノード：\n- 配列/リストの反復をサポート\n- 各要素に同じ処理を実行\n- 最大反復回数を設定可能\n- バッチ処理シナリオに適している\n\n例：ユーザーリストを反復し、各ユーザーのレポートを生成。",
      "difficulty": "medium"
    },
    {
      "id": "q45",
      "domain": 4,
      "question": "Q&A チャンキングモードはどのタイプのコンテンツに適していますか？",
      "options": {
        "A": "連続した叙述的な記事",
        "B": "FAQ形式の質問と回答のペアコンテンツ",
        "C": "コードファイル",
        "D": "画像ファイル"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Q&Aチャンキングモード：\n- 質問と回答のペア専用に設計\n- 各チャンクには1つの質問と対応する回答が含まれる\n- 検索時は質問にマッチ\n- 対応する回答を返す\n\nFAQ、製品Q&Aなどの構造化コンテンツに適しています。",
      "difficulty": "easy"
    },
    {
      "id": "q46",
      "domain": 4,
      "question": "ナレッジベースの「メタデータフィルタリング」機能の役割は何ですか？",
      "options": {
        "A": "無駄なデータを削除",
        "B": "ドキュメント属性（ソース、日付など）に基づいて検索範囲をフィルタリング",
        "C": "ストレージスペースを圧縮",
        "D": "コンテンツを翻訳"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "メタデータフィルタリングの役割：\n- ドキュメント属性に基づいて検索範囲をフィルタリング\n- ソース、日付、タイプなどによるフィルタリングをサポート\n- 検索の関連性を向上\n- 複数タイプのドキュメントが混在するナレッジベースに適している\n\n例：2024年の製品ドキュメントのみを検索。",
      "difficulty": "medium"
    },
    {
      "id": "q47",
      "domain": 1,
      "question": "Dify がサポートするオブジェクトストレージサービスはどれですか？（2つ選択）",
      "options": {
        "A": "AWS S3",
        "B": "Azure Blob Storage",
        "C": "ローカルストレージのみサポート",
        "D": "オブジェクトストレージはサポートされていない"
      },
      "answer": ["A", "B"],
      "answerType": "multiple",
      "explanation": "Difyは複数のオブジェクトストレージをサポートしています：\n- ローカルストレージ（デフォルト）\n- AWS S3\n- Azure Blob Storage\n- Alibaba Cloud OSS\n- Tencent Cloud COS\n\n本番環境では信頼性を向上させるためにクラウドストレージの使用を推奨します。",
      "difficulty": "medium"
    },
    {
      "id": "q48",
      "domain": 2,
      "question": "Prompt の「反復最適化」とは何ですか？",
      "options": {
        "A": "一度にプロンプトを書き上げる",
        "B": "テスト結果に基づいてプロンプトを繰り返し修正・改善",
        "C": "ループ文を使用",
        "D": "プロンプトを複数コピー"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Prompt反復最適化：\n1. 初期Promptを作成\n2. テストして結果を収集\n3. 問題と不足点を分析\n4. Promptを修正\n5. 満足するまでテストを繰り返す\n\nこれがPromptエンジニアリングのコア方法論です。",
      "difficulty": "easy"
    },
    {
      "id": "q49",
      "domain": 3,
      "question": "Workflow でノード実行の失敗を処理するにはどうすればよいですか？",
      "options": {
        "A": "フロー全体が即座に終了",
        "B": "失敗処理分岐とリトライロジックを設定可能",
        "C": "エラーを自動的に無視して実行を継続",
        "D": "エラー処理メカニズムがない"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Workflowのエラー処理：\n- 失敗時の処理分岐を設定可能\n- リトライメカニズムをサポート\n- タイムアウト時間を設定可能\n- エラー情報をキャプチャして後続ノードに渡せる\n\n完全なエラー処理は本番レベルのアプリケーションに必須の条件です。",
      "difficulty": "medium"
    },
    {
      "id": "q50",
      "domain": 4,
      "question": "Dify アプリケーションの使用状況を監視するにはどうすればよいですか？",
      "options": {
        "A": "ログファイルでのみ可能",
        "B": "組み込みの監視パネルで呼び出し量、トークン消費などを確認",
        "C": "監視機能がない",
        "D": "サードパーティツールが必要"
      },
      "answer": "B",
      "answerType": "single",
      "explanation": "Difyの組み込み監視機能：\n- API呼び出し量の確認\n- トークン消費統計\n- 応答時間分析\n- ユーザーアクティビティ\n- エラー率監視\n\nこれらのデータはアプリケーションの最適化とコスト管理に役立ちます。",
      "difficulty": "easy"
    }
  ]
}
